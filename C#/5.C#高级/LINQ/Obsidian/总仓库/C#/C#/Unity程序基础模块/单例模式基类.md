# 非典型的单例模式
[单例模式基类](file:///G:/Unity/Unity%E9%A1%B9%E7%9B%AE/Framework/Assets/Scripts/ProjectBase/Base/SingletonMono.cs)

# 典型的单例模式
## 1、[饿汉式单例模式（Eager Singleton）](file:///G:/Unity/Unity%E9%A1%B9%E7%9B%AE/Framework/Assets/Scripts/ProjectBase/Base/EagerSingleton.cs)：
- 在类加载时就创建实例。
- 私有化构造函数，防止外部实例化。
- 提供一个静态的只读属性来获取实例。
- 代码示例：
`// 在C#中，静态成员在类的构造函数之前被调用。静态成员是在类第一次被使用之前就被初始化的，而类的构造函数是在实例化类的对象时被调用的。
//静态成员包括静态字段、静态属性和静态方法。它们会在程序运行时，无论是否创建类的实例，都会被初始化和调用
public class Singleton
{
    private static readonly Singleton instance = new Singleton();

    private Singleton() { }

    public static Singleton Instance
    {
        get { return instance; }
    }
}
`
饿汉式变体1：
`public class SingleTon1
{
    private SingleTon1()
    {
    }
    public static SingleTon1 getInstance()
    {
        return Inner.single;
    }
    private static class Inner
    {
        internal static SingleTon1 single = new SingleTon1();
    }
}
`

饿汉式单例模式的优缺点
​ 饿汉式单例模式适用于单例对象较少的情况。这样可以保证绝对线程安全、执行效率比较高。

​ 但饿汉式单例模式的缺点也是否明显，那就说所有对象类加载的时候就实例化。这样一来，如果系统中有大批量的单例对象存在，系统初始化时就会导致大量的内存浪费。即无论对象用与不用都占着空间，浪费了内存

## 2、懒汉式单例模式（Lazy Singleton）：
在需要时才创建实例。
私有化构造函数，防止外部实例化。
使用一个静态变量来保存实例，初始值为null。
提供一个静态的只读属性来获取实例，如果实例为null，则进行实例化。
使用双重锁定（double-checked locking）来确保线程安全。
代码示例：
public class Singleton
{
    private static Singleton instance = null;
    private static readonly object lockObj = new object();

    private Singleton() { }

    public static Singleton Instance
    {
        get
        {
            if (instance == null)
            {
                lock (lockObj)
                {
                    if (instance == null)
                    {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
    }
}


