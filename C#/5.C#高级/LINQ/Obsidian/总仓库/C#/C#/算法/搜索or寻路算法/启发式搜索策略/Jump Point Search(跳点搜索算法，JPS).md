[JPS/JPS+ 寻路算法 - KillerAery - 博客园](https://www.cnblogs.com/KillerAery/p/12242445.html#%E5%BC%BA%E8%BF%AB%E9%82%BB%E5%B1%85forced-neighbour)
## Jump Point Search(JPS)
JPS算法又叫跳点搜索算法，在保留A*算法框架的同时，进一步优化了A*寻找后继节点的操作。

**以下数据来自网络**
假设场景起点终点差距200格子，需要寻路10000次。

A*寻路总时间为**2.6074 x 10^11 ns**

基础JPS寻路总时间为**1.7037 x 10^10 ns**

利用位运算优化的JPS（JPS-Bit)寻路总时间为**3.2363 x 10^9 ns**

利用位运算和剪枝优化的JPS（JPS-BitPrune)寻路总时间为**2.0043 x 10^9 ns**

利用位运算和剪枝优化和预处理的JPS（JPS-BitPrunePre)寻路总时间为**9.5434 x 10^8 ns**

从数据可以直观看出，在此环境下，五版JPS算法寻路速度为A*的15倍，81倍，110倍，130倍，273倍，速度方面大幅超越了A*。

JPS寻路算法已经被证明是基于无权重格子，在没有预处理情况下最快的寻路算法。

流程图：
![](https://pica.zhimg.com/v2-e9fa2dd63c265633fc61f512870f8122_1440w.jpg)

### 两个定义：
强迫邻居（forced neighbour）：

如果点 n 是 x 的邻居，并且点 n 的邻居有阻挡（不可行走的格子），并且从 parent(x)、x、n 的路径长度比其他任何从 parent(x)到 n 且不经过 x 的路径短，其中parent(x)为路径中 x 的前一个点，则 n 为 x 的强迫邻居，x 为 n 的跳点），例如图 2 中，寻找从 S 到 E的路径时，K 为 I 的强迫邻居（I 为 K 的跳点）。这里不认为从 H 到 K 能走，因为对角线有阻挡（这点和论文不一致，但和代码一致，因为如果 H 到 K 能直接到达，会走进 H 右边的阻挡区，大部分的 JPS 开源代码根据论文都认为 H 到 K能走，所以存在穿越阻挡的情况），如果需要 H 到 K 可走，则 K 为 H的强迫邻居（H 为 K的跳点）。

  

跳点（jump point）：
（1）如果点 y 是起点或目标点，则 y 是跳点，例如图 2 中，S 是起点也是跳点，E 是目标点也是跳点；（2）如果 y 有邻居且是强迫邻居则 y 是跳点， 例 如 I 是跳点，请注意此类跳点和强迫邻居是伴生系，从上文强迫邻居的定义来看 n 是强迫邻居，x 是跳点，二者的关系是伴生的，例如图 2 中 K 的邻居只有I 是跳点，M 虽然也是 K的邻居，但 M 不是跳点，因为 K 不是 M 的强迫邻居；（3）如果 parent(y)到 y 是对角线移动，并且 y 经过水平或垂直方向移动可以到达跳点，则 y 是跳点，例如图 2 中 G 是跳点，因为 parent(G)为 S，S 到 G 为对角线移动，从 G 到跳点 I 为垂直方向移动，I 是跳点，所以 G 也是跳点。

### 三个规则
规则一：JPS 搜索跳点的过程中，如果直线方向（为了和对角线区分，直线方向代表水平方向、垂直方向，下文所说的直线均为水平方向和垂直方向）、对角线方向都可以移动，则首先在直线方向搜索跳点，再在对角线方向搜索跳点。

规则二：（1）如果从 parent(x)到 x 是直线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于或等于从 parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n；（2）果从 parent(x)到 x 是对角线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于从parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n（相关证明见论文）。

规则三：只有跳点才会加入 openset，因为跳点会改变行走方向，而非跳点不会改变行走方向，最后寻找出来的路径点也只会是跳点集合的子集。

### 寻路过程：
若 current 当前方向是直线方向：
（1）如果 current 左后方不可走且左方可走（即左方是强迫邻居），则沿 current左前方和左方寻找不在 closedset 的跳点；
（2）如果 current 当前方向可走，则沿 current 当前方向寻找不在 closed 集合的跳点；
（3）如果 current 右后方不可走且右方可走（右方是强迫邻居），则沿 current右前方和右方寻找不在 closedset 的跳点；
若 current 当前方向为对角线方向：
（1）如果 current 当前方向的水平分量可走（例如 current 当前为东北方向，则水平分量为东），则沿 current 当前方向的水平分量寻找不在 closedset 的跳点；
（2）如果 current 当前方向可走，则沿 current 当前方向寻找不在 closedset的跳点；
（3）如果 current 当前方向的垂直分量可走（例如 current 当前为东北方向，则垂直分量为北），则沿 current 当前方向的垂直分量寻找不在 closedset 的跳点。.