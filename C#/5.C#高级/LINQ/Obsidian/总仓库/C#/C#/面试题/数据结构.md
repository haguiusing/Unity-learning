- 介绍二叉搜索树与平衡二叉搜索树
[二叉查找树与平衡二叉树的区别_二叉平衡树和二叉查找树的区别-CSDN博客](https://blog.csdn.net/qq_42610605/article/details/100095307)

相同点：
都是基于分治思想采用二分法的策略提高数据查找速度的二叉树结构。

不同点：
二叉查找树的根节点是不可变的，左右两边结点层级差没有限制；
平衡二叉树左右两边结点层级相差不大于1，通过旋转实现根节点可变，达到自平衡。
相对于二叉查找树，平衡二叉树的查询效率高，但由于增加和删除节点时，为了保证自平衡会做连续的旋转操作，平衡二叉树的额外开销比较大，耗时相对较长。

- 有哪几种常用的平衡二叉搜索树（AVL，红黑树），如何保持平衡
## AVL树
[几种常见的树：排序二叉树、平衡二叉树、红黑树、B+树 - 静水楼台/Java部落阁 - 博客园](https://www.cnblogs.com/rouqinglangzi/p/6906230.html#_label0)
[平衡二叉树（AVL树）：原理、常见算法及其应用_avl树应用-CSDN博客](https://blog.csdn.net/weixin_43841461/article/details/142414109)

## 红黑树
![[Pasted image 20250416005842.png]]
![[Pasted image 20250416010129.png]]
![[Pasted image 20250416010311.png]]
- 红黑树的着色规则
- 红黑树的旋转操作

- 红黑树的插入算法
（新插入节点颜色为黑色，会变全黑树）
（新插入节点颜色必需为红色）2、4规则可能违背
[红黑树（图解+秒懂+史上最全） - 疯狂创客圈 - 博客园](https://www.cnblogs.com/crazymakercircle/p/16320430.html)
### 场景1：红黑树为空树
直接把插入结点作为根节点就可以了
另外：根据红黑树性质 2根节点是黑色的。还需要把插入节点设置为黑色。
![[Pasted image 20250416143230.png]]
### 场景2：插入节点的Key已经存在
更新当前节点的值，为插入节点的值。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412094118977.png)

### 情景3：插入节点的父节点为黑色
由于插入的节点是红色的，当插入节点的父节点是黑色时，不会影响红黑树的平衡，
所以： **直接插入无需做自平衡**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412094724987.png)

### 情景4：插入节点的父节点为红色
根据性质2：根节点是黑色。
如果插入节点的父节点为红色节点，那么该父节点不可能为根节点，所以插入节点总是存在祖父节点(三代关系)。
根据性质4：每个**红色**节点的两个子节点一定是**黑色**的。不能有**两个红色节点相连**。此时会出现两种状态：
- 父亲和叔叔为红色
    
- 父亲为红色，叔叔为黑色
    
如图
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412100154174.png)
#### 场景4.1：父亲和叔叔为红色节点
根据性质4：**红色节点不能相连 》祖父节点肯定为黑色节点：**
父亲为红色，那么此时该插入子树的红黑树层数的情况是：黑红红。
因为不可能同时存在两个相连的红色节点，需要进行 变色， 显然处理方式是把其改为：红黑红
**变色 处理**：黑红红 ==> 红黑红
1.将F和V节点改为黑色
2.将P改为红色
3.将P设置为当前节点，进行后续处理
![[Pasted image 20250416151402.png]]
![[Pasted image 20250416151414.png]]

#### 场景4.2：叔叔为黑色，父亲为红色，并且插在父亲的左节点
分为两种情况
- LL 红色插入
- LR 红色插入
##### 场景4.2.1 LL型失衡
细分场景 1： 新插入节点，为其父节点的左子节点(LL红色情况)， 插入后 就是LL 型失衡
![[Pasted image 20250416151641.png]]
###### 自平衡处理：
1.变颜色：将F设置为黑色，将P设置为红色
2.对F节点进行**右旋**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412160626713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZhbGxpbmdfc3RhcnNf,size_16,color_FFFFFF,t_70)

##### 场景4.2.2 LR型失衡
细分场景 2： 新插入节点，为其父节点的右子节点(LR红色情况)， 插入后 就是LR 型失衡
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412153113242.png)

###### 自平衡处理：
1.对F进行左旋
2.将F设置为当前节点，得到LL红色情况
3.按照LL红色情况处理(1.变色 2.右旋P节点)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412153954767.png)

#### 情景4.3：叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点
##### 情景4.3.1：RR型失衡
新插入节点，为其父节点的右子节点(RR红色情况)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412155529702.png)

###### 自平衡处理：
1.变色：将F设置为黑色，将P设置为红色
2.对P节点进行**左旋**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412160829355.png)

##### 情景4.3.2：RL型失衡
新插入节点，为其父节点的左子节点(RL红色情况)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412161045393.png)

###### 自平衡处理：
1.对F进行右旋
2.将F设置为当前节点，得到RR红色情况
3.按照RR红色情况处理(1.变色 2.左旋 P节点)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412161924591.png)


![[Pasted image 20250416143608.png]]

### RBT面试题
#### **问：有了二叉搜索树，为什么还需要平衡二叉树？**
二叉搜索树容易退化成一条链
这时，查找的时间复杂度从O ( log n）也将退化成O ( N )
引入对左右子树高度差有限制的平衡二叉树 AVL，保证查找操作的最坏时间复杂度也为O ( log n）
#### 问：有了平衡二叉树，为什么还需要红黑树？
AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡
在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，
整体性能优于AVL
- 红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决
    
- 红黑树的红黑规则，保证最坏的情况下，也能在O ( log n）时间内完成查找操作。
#### 问：红黑树那几个原则，你还记得么？
可以按照括号里边的分类，记住 红黑树的几个原则：
- （**颜色属性**）节点非黑即红
    
- （**根属性**）根节点一定是黑色
    
- （**叶子属性**）叶子节点（NIL）一定是黑色
    
- （**红色属性**）每个红色节点的两个子节点，都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
    
- （黑色属性）从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。
#### 问：红黑树的有那些内部操作
**变色**：把一个红色的节点变成黑色，或者把一个黑色的节点变成红色，就是对这个节点的`变色`。
**旋转**：与平衡二叉树的旋转操作类似。
#### 红黑树与AVL树区别
**1、调整平衡的实现机制不同**
红黑树根据路径上黑色节点数目一致，来确定是否失衡，如果失衡，就通过变色和旋转来恢复
AVL根据树的[平衡因子](https://so.csdn.net/so/search?q=%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90&spm=1001.2101.3001.7020)(**所有节点的左右子树高度差的绝对值不超过1**)，来确定是否失衡，如果失衡，就通过旋转来恢复

**2、红黑树的插入效率更高**
红黑树是用**非严格的平衡**来换取增删节点时候旋转次数的降低，**任何不平衡都会在三次旋转之内解决**，
红黑树并不追求“完全平衡”，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能
而AVL是**严格平衡树**(高度平衡的二叉搜索树)，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。
所以红黑树的插入效率更高

**3、红黑树统计性能比AVL树更高**
红黑树能够以**O(log n)** 的时间复杂度进行查询、插入、删除操作。
AVL树查找、插入和删除在平均和最坏情况下都是**O(log n)**。
红黑树的算法时间复杂度和AVL相同，**但统计性能比AVL树更高**，

**4、适用性：AVL查找效率高**
**如果你的应用中，查询的次数远远大于插入和删除，那么选择AVL树，如果查询和插入删除次数几乎差不多，应选择红黑树**。
即，有时仅为了排序（建立-遍历-删除），不查找或查找次数很少，R-B树合算一些。

- 哈希表的底层实现
- 哈希碰撞的解决办法（开链法，线性探测法）