## 状态模式
在状态模式（State Pattern）中，类的行为是基于它的状态改变的，这种类型的设计模式属于行为型模式。
在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。
状态模式允许对象在内部状态改变时改变其行为，使得对象在不同的状态下有不同的行为表现。通过将每个状态封装成独立的类，可以避免使用大量的条件语句来实现状态切换。

模式结构：
- Context：上下文
- State：状态
- Concrete State：具体状态

状态模式包含以下几个主要角色：
- **上下文（Context）**：定义了客户感兴趣的接口，并维护一个当前状态对象的引用。上下文可以通过状态对象来委托处理状态相关的行为。
- **状态（State）**：定义了一个接口，用于封装与上下文相关的一个状态的行为。
- **具体状态（Concrete State）**：实现了状态接口，负责处理与该状态相关的行为。具体状态对象通常会在内部维护一个对上下文对象的引用，以便根据不同的条件切换到不同的状态。
- 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。

![[Pasted image 20250425151307.png]]

1. `IState` 接口：状态接口，定义了状态的行为方法
2. `StartState` 和 `StopState` 类：具体状态类，实现了状态接口并定义了具体的行为
3. `Context` 类：上下文类，维护当前状态，并提供设置和获取状态的方法
4. `StatePatternDemo` 类：客户类，演示如何使用状态模式

``` cs
using System;

// State: 状态接口
public interface IState
{
    void DoAction(Context context);
}

// Concrete State: 具体状态类
// StartState类
public class StartState : IState
{
    public void DoAction(Context context)
    {
        Console.WriteLine("Player is in start state");
        context.State = this;
    }

    public override string ToString()
    {
        return "Start State";
    }
}

// StopState类
public class StopState : IState
{
    public void DoAction(Context context)
    {
        Console.WriteLine("Player is in stop state");
        context.State = this;
    }

    public override string ToString()
    {
        return "Stop State";
    }
}

// Context: 上下文类
public class Context
{
    private IState state;

    public IState State
    {
        get { return state; }
        set { state = value; }
    }

    public Context()
    {
        state = null;
    }
}

// Client: 客户类
public class StatePatternDemo
{
    public static void Main(string[] args)
    {
        Context context = new Context();

        IState startState = new StartState();
        startState.DoAction(context);

        Console.WriteLine(context.State.ToString());

        IState stopState = new StopState();
        stopState.DoAction(context);

        Console.WriteLine(context.State.ToString());
    }
}
```

执行该程序后，输出结果与原始 Java 版本相同：
```cs
Player is in start state
Start State
Player is in stop state
Stop State
```

## 与其他模式的关系
- [桥接模式](https://refactoringguru.cn/design-patterns/bridge)、 [状态模式](https://refactoringguru.cn/design-patterns/state)和[策略模式](https://refactoringguru.cn/design-patterns/strategy) （在某种程度上包括[适配器模式](https://refactoringguru.cn/design-patterns/adapter)） 模式的接口非常相似。 实际上， 它们都基于[组合模式](https://refactoringguru.cn/design-patterns/composite)——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。
    
- [状态](https://refactoringguru.cn/design-patterns/state)可被视为[策略](https://refactoringguru.cn/design-patterns/strategy)的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 _策略_使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但_状态_模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。