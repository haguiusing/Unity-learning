## 模板方法模式
在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。


模式结构：
- Abstract Class：抽象父类
- Concrete Classes：具体子类
- Hook Method：钩子方法
- Client：客户端

包含的几个主要角色
- **抽象父类（Abstract Class）**：
    - 定义了模板方法和一些抽象方法或具体方法。
- **具体子类（Concrete Classes）**：
    - 继承自抽象父类，并实现抽象方法。
- **钩子方法（Hook Method）（可选）**：
    - 在抽象父类中定义，可以被子类重写，以影响模板方法的行为。
- **客户端（Client）（可选）**：
    - 使用抽象父类和具体子类，无需关心模板方法的细节。

![[Pasted image 20250425161119.jpg]]

1. `Game` 类：抽象父类，定义了模板方法 `Play()` 和抽象方法 `Initialize()`, `StartPlay()`, `EndPlay()`
2. `Cricket` 和 `Football` 类：具体子类，实现了抽象父类的抽象方法
3. `TemplatePatternDemo` 类：客户端类，演示如何使用模板模式
```cs
using System;

// Abstract Class: 抽象父类
public abstract class Game
{
    // 模板方法
    public void Play()
    {
        Initialize();
        StartPlay();
        EndPlay();
        PrintScore(); // 调用钩子方法
    }

    // 抽象钩子方法
    protected abstract void Initialize();
    protected abstract void StartPlay();
    protected abstract void EndPlay();

    // 具体钩子方法（可选）
    protected virtual void PrintScore()
    {
        Console.WriteLine("Default score printing logic.");
    }
}

// Concrete Classes: 具体子类
// Cricket类
public class Cricket : Game
{
    protected override void EndPlay()
    {
        Console.WriteLine("Cricket Game Finished!");
    }

    protected override void Initialize()
    {
        Console.WriteLine("Cricket Game Initialized! Start playing.");
    }

    protected override void StartPlay()
    {
        Console.WriteLine("Cricket Game Started. Enjoy the game!");
    }

    // 覆盖可选钩子方法
    protected override void PrintScore()
    {
        Console.WriteLine("Cricket Score: 200 runs");
    }
}

// Football类
public class Football : Game
{
    protected override void EndPlay()
    {
        Console.WriteLine("Football Game Finished!");
    }

    protected override void Initialize()
    {
        Console.WriteLine("Football Game Initialized! Start playing.");
    }

    protected override void StartPlay()
    {
        Console.WriteLine("Football Game Started. Enjoy the game!");
    }

    // 覆盖可选钩子方法
    protected override void PrintScore()
    {
        Console.WriteLine("Football Score: 3 goals");
    }
}

// 客户端
public class TemplatePatternDemo
{
    public static void Main(string[] args)
    {
        Game game = new Cricket();
        game.Play();
        Console.WriteLine();

        game = new Football();
        game.Play();
    }
}
```

执行该程序后，输出结果：
```
Cricket Game Initialized! Start playing.
Cricket Game Started. Enjoy the game!
Cricket Game Finished!
Cricket Score: 200 runs

Football Game Initialized! Start playing.
Football Game Started. Enjoy the game!
Football Game Finished!
Football Score: 3 goals
```

##  与其他模式的关系
- [工厂方法模式](https://refactoringguru.cn/design-patterns/factory-method)是[模板方法模式](https://refactoringguru.cn/design-patterns/template-method)的一种特殊形式。 同时， _工厂方法_可以作为一个大型_模板方法_中的一个步骤。
    
- [模板方法](https://refactoringguru.cn/design-patterns/template-method)基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 [策略模式](https://refactoringguru.cn/design-patterns/strategy)基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 _模板方法_在类层次上运作， 因此它是静态的。 _策略_在对象层次上运作， 因此允许在运行时切换行为。