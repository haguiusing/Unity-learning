## 观察者模式
观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。

模式结构：
- Subject：主题 / 发布者（Publisher）
- Concrete Subject：具体主题 / 具体发布者（Concrete Publisher）
- Observer：观察者 / 订阅者 （Subscriber）
- Concrete Observer：具体观察者 / 具体订阅者（Concrete Subscribers）

**观察者模式包含以下几个核心角色：**
- **主题**（Subject）：也称为被观察者或可观察者，它是具有状态的对象，并维护着一个观察者列表。主题提供了添加、删除和通知观察者的方法。
- **具体主题**（Concrete Subject）：具体主题是主题的具体实现类。它维护着观察者列表，并在状态发生改变时通知观察者。
- **观察者**（Observer）：观察者是接收主题通知的对象。观察者需要实现一个更新方法，当收到主题的通知时，调用该方法进行更新操作。
- **具体观察者**（Concrete Observer）：具体观察者是观察者的具体实现类。它实现了更新方法，定义了在收到主题通知时需要执行的具体操作。
- 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。
- **客户端** （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。

![[Pasted image 20250425145512.jpg]]

1. `Subject` 类：主题类，维护观察者列表并提供注册和通知方法
2. `IObserver` 接口：观察者接口，定义了更新方法
3. `BinaryObserver`、`OctalObserver` 和 `HexaObserver` 类：具体观察者类，实现观察者接口并在主题状态改变时更新
4. `ObserverPatternDemo` 类：客户端类，演示如何使用观察者模式

```cs
using System;
using System.Collections.Generic;

// Subject: 主题类
public class Subject
{
    private List<IObserver> observers = new List<IObserver>();
    private int state;

    public int State
    {
        get { return state; }
        set
        {
            state = value;
            NotifyAllObservers();
        }
    }

    public void Attach(IObserver observer)
    {
        observers.Add(observer);
    }

	public void Detach(Observer observer)
    {
        observers.Remove(observer);
    }

    public void NotifyAllObservers()
    {
        foreach (IObserver observer in observers)
        {
            observer.Update();
        }
    }
}

// Observer: 观察者接口
public interface IObserver
{
    void Update();
}

// ConcreteObserver: 具体观察者
// BinaryObserver类
public class BinaryObserver : IObserver
{
    private Subject subject;

    public BinaryObserver(Subject subject)
    {
        this.subject = subject;
        this.subject.Attach(this);
    }

    public void Update()
    {
        Console.WriteLine("Binary String: " + Convert.ToString(subject.State, 2));
    }
}

// OctalObserver类
public class OctalObserver : IObserver
{
    private Subject subject;

    public OctalObserver(Subject subject)
    {
        this.subject = subject;
        this.subject.Attach(this);
    }

    public void Update()
    {
        Console.WriteLine("Octal String: " + Convert.ToString(subject.State, 8));
    }
}

// HexaObserver类
public class HexaObserver : IObserver
{
    private Subject subject;

    public HexaObserver(Subject subject)
    {
        this.subject = subject;
        this.subject.Attach(this);
    }

    public void Update()
    {
        Console.WriteLine("Hex String: " + Convert.ToString(subject.State, 16).ToUpper());
    }
}

// Client: 客户类
public class ObserverPatternDemo
{
    public static void Main(string[] args)
    {
        Subject subject = new Subject();

        new HexaObserver(subject);
        new OctalObserver(subject);
        new BinaryObserver(subject);

        Console.WriteLine("First state change: 15");
        subject.State = 15;
        Console.WriteLine("Second state change: 10");
        subject.State = 10;
    }
}
```

执行该程序后，输出结果：
```cs
First state change: 15
Hex String: F
Octal String: 17
Binary String: 1111
Second state change: 10
Hex String: A
Octal String: 12
Binary String: 1010
```
## 与其他模式的关系
- [责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)、 [命令模式](https://refactoringguru.cn/design-patterns/command)、 [中介者模式](https://refactoringguru.cn/design-patterns/mediator)和[观察者模式](https://refactoringguru.cn/design-patterns/observer)用于处理请求发送者和接收者之间的不同连接方式：
    - _责任链_按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
    - _命令_在发送者和请求者之间建立单向连接。
    - _中介者_清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
    - _观察者_允许接收者动态地订阅或取消接收请求。

- [中介者](https://refactoringguru.cn/design-patterns/mediator)和[观察者](https://refactoringguru.cn/design-patterns/observer)之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。
    
    _中介者_的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 _观察者_的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。
    
    有一种流行的中介者模式实现方式依赖于_观察者_。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当_中介者_以这种方式实现时， 它可能看上去与_观察者_非常相似。
    
    当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和_观察者_并不相同， 但这仍是一种中介者模式。
    
    假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。