## 命令模式
**命令模式**是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

模块结构：
- Command: 抽象命令类
- ConcreteCommand: 具体命令类
- Invoker: 调用者
- Receiver: 接收者
- Client:客户类

**主要涉及到以下几个核心角色：**
- **命令（Command）:**
    - 定义了执行操作的接口，通常包含一个 `execute` 方法，用于调用具体的操作。
- **具体命令（ConcreteCommand）:**
    - 实现了命令接口，负责执行具体的操作。它通常包含了对接收者的引用，通过调用接收者的方法来完成请求的处理。
- **接收者（Receiver）:**
    - 知道如何执行与请求相关的操作，实际执行命令的对象。
- **调用者/请求者（Invoker）:**
    - 发送命令的对象，它包含了一个命令对象并能触发命令的执行。调用者并不直接处理请求，而是通过将请求传递给命令对象来实现。
- **客户端（Client）:**
    - 创建具体命令对象并设置其接收者，将命令对象交给调用者执行。

![[Pasted image 20250424211603.jpg]]

- **`ICommand` 抽象命令类**：定义了执行命令的接口。
- **`StockReceiver` 接收者**：定义了执行具体操作的类，包含买入和卖出股票的方法。
- **`BuyStockCommand` 和 `SellStockCommand` 具体命令类**：实现了 `ICommand` 接口，分别封装了买入和卖出股票的请求。
- **`Invoker` 调用者**：负责接收和执行命令，维护一个命令列表。
- **`Client` 客户类**：创建接收者对象、命令对象和调用者对象，并将命令提交给调用者执行。

``` cs
using System;
using System.Collections.Generic;

// 抽象命令类
public interface ICommand
{
    void Execute();
}

// 接收者
public class StockReceiver
{
    private string name = "ABC";
    private int quantity = 10;

    public void Buy()
    {
        Console.WriteLine($"Stock [ Name: {name}, Quantity: {quantity} ] bought");
    }

    public void Sell()
    {
        Console.WriteLine($"Stock [ Name: {name}, Quantity: {quantity} ] sold");
    }
}

// 具体命令类：买入股票命令
public class BuyStockCommand : ICommand
{
    private StockReceiver _stockReceiver;

    public BuyStockCommand(StockReceiver stockReceiver)
    {
        _stockReceiver = stockReceiver;
    }

    public void Execute()
    {
        _stockReceiver.Buy();
    }
}

// 具体命令类：卖出股票命令
public class SellStockCommand : ICommand
{
    private StockReceiver _stockReceiver;

    public SellStockCommand(StockReceiver stockReceiver)
    {
        _stockReceiver = stockReceiver;
    }

    public void Execute()
    {
        _stockReceiver.Sell();
    }
}

// 调用者
public class Invoker
{
    private List<ICommand> _commands = new List<ICommand>();

    public void TakeCommand(ICommand command)
    {
        _commands.Add(command);
    }

    public void PlaceOrders()
    {
        foreach (ICommand command in _commands)
        {
            command.Execute();
        }
        _commands.Clear();
    }
}

// 客户类
public class Client
{
    public static void Main(string[] args)
    {
        StockReceiver stockReceiver = new StockReceiver();

        ICommand buyStockCommand = new BuyStockCommand(stockReceiver);
        ICommand sellStockCommand = new SellStockCommand(stockReceiver);

        Invoker invoker = new Invoker();
        invoker.TakeCommand(buyStockCommand);
        invoker.TakeCommand(sellStockCommand);

        invoker.PlaceOrders();
    }
}
```

### 运行结果
```cs
Stock [ Name: ABC, Quantity: 10 ] bought
Stock [ Name: ABC, Quantity: 10 ] sold
```

![[Pasted image 20250424211610.jpg]]

## 与其他模式的关系
- [责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)、 [命令模式](https://refactoringguru.cn/design-patterns/command)、 [中介者模式](https://refactoringguru.cn/design-patterns/mediator)和[观察者模式](https://refactoringguru.cn/design-patterns/observer)用于处理请求发送者和接收者之间的不同连接方式：
    - _责任链_按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
    - _命令_在发送者和请求者之间建立单向连接。
    - _中介者_清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
    - _观察者_允许接收者动态地订阅或取消接收请求。
    
- [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)的管理者可使用[命令模式](https://refactoringguru.cn/design-patterns/command)实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。
    还有另外一种实现方式， 那就是请求自身就是一个_命令_对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。
    
- 你可以同时使用[命令](https://refactoringguru.cn/design-patterns/command)和[备忘录模式](https://refactoringguru.cn/design-patterns/memento)来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。
    
- [命令](https://refactoringguru.cn/design-patterns/command)和[策略模式](https://refactoringguru.cn/design-patterns/strategy)看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。
    - 你可以使用_命令_来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。
        
    - 另一方面， _策略_通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。
        
- [原型模式](https://refactoringguru.cn/design-patterns/prototype)可用于保存[命令](https://refactoringguru.cn/design-patterns/command)的历史记录。
    
- 你可以将[访问者模式](https://refactoringguru.cn/design-patterns/visitor)视为[命令模式](https://refactoringguru.cn/design-patterns/command)的加强版本， 其对象可对不同类的多种对象执行操作。

下面是一个不使用命令模式的Unity代码示例，它实现了的功能——移动游戏对象。
```csharp
public class PlayerController : MonoBehaviour
{
    public GameObject player;
    public Vector3 moveDirection = new Vector3(1, 0, 0);

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            MovePlayer();
        }
    }

    private void MovePlayer()
    {
        player.transform.Translate(moveDirection);
    }
}
```
在这个示例中，`PlayerController` 脚本直接包含了移动玩家的逻辑。当用户按下空格键时，`MovePlayer` 方法会被调用，玩家对象会沿着指定的方向移动。

这种方式的缺点是：
1. **耦合度高**：游戏逻辑和玩家移动的实现紧密耦合在一起，如果需要改变移动逻辑，可能需要修改多个地方的代码。
2. **扩展性差**：如果需要添加新的操作（例如跳跃、攻击等），你可能需要在`PlayerController`类中添加更多的方法，这会导致类变得越来越复杂。
3. **难以维护**：随着游戏逻辑的增加，`PlayerController`类可能会变得非常庞大，难以阅读和维护。

下面是一个简单的Unity命令模式的示例：

1. **定义命令接口**：所有命令对象都应该实现这个接口。
```csharp
public interface ICommand
{
    void Execute();
}
```

2. **创建具体的命令类**：这些类实现了命令接口，并定义了具体的执行逻辑。
```csharp
public class MoveCommand : ICommand
{
    private GameObject _gameObject;
    private Vector3 _direction;

    public MoveCommand(GameObject gameObject, Vector3 direction)
    {
        _gameObject = gameObject;
        _direction = direction;
    }

    public void Execute()
    {
        _gameObject.transform.Translate(_direction);
    }
}
```

3. **创建调用者（Invoker）类**：这个类负责调用命令对象。
```csharp
public class CommandInvoker
{
    private ICommand _command;

    public void SetCommand(ICommand command)
    {
        _command = command;
    }

    public void ExecuteCommand()
    {
        _command.Execute();
    }
}
```

4. **客户端代码**：客户端代码创建具体的命令对象，并设置给调用者。
```csharp
public class Game
{
    public void Start()
    {
        GameObject player = GameObject.Find("Player");
        CommandInvoker invoker = new CommandInvoker();
        ICommand moveCommand = new MoveCommand(player, new Vector3(1, 0, 0));

        invoker.SetCommand(moveCommand);
        invoker.ExecuteCommand();
    }
}
```
在这个例子中，`MoveCommand` 是一个具体的命令，它封装了移动游戏对象的逻辑。`CommandInvoker` 是调用者，它有一个方法来执行命令。在游戏的某个逻辑点，我们创建了一个移动命令，并将其设置给调用者，然后执行这个命令。

这个模式的好处是，你可以很容易地添加新的命令，而不需要修改调用者类。此外，命令模式也支持撤销操作，你只需要在命令接口中添加一个 `Undo` 方法即可。

在命令模式中，一个命令类通常封装一个特定的操作或请求。因此，按照这个原则，一个命令类确实只封装一个命令。这样做的目的是为了保持每个命令的单一职责，使得每个命令类都是自包含的，并且只负责执行一个具体的操作。

然而，这并不意味着一个命令类不能执行多个操作。如果一个操作可以分解为多个步骤，你可以在同一个命令类中按顺序执行这些步骤。关键在于这些步骤是否构成了一个逻辑上的单一操作。如果它们是紧密相关的，可以视为一个单一命令；如果它们是独立的，那么最好将它们分别封装在不同的命令类中。

例如，如果你有一个复杂的操作，比如“打开门”，这个操作可能包括以下几个步骤：
1. 检查是否有钥匙。
2. 转动钥匙。
3. 推门。

在这种情况下，你可以创建一个`OpenDoorCommand`类，它封装了上述所有步骤。这个命令类仍然只封装了一个命令，即“打开门”，但它在内部执行了多个步骤。
```csharp
public class OpenDoorCommand : ICommand
{
    private Door _door;

    public OpenDoorCommand(Door door)
    {
        _door = door;
    }

    public void Execute()
    {
        if (_door.HasKey())
        {
            _door.TurnKey();
            _door.Push();
        }
    }
}
```
在这个例子中，`OpenDoorCommand`类封装了“打开门”这个单一命令，但它在执行时会依次执行检查钥匙、转动钥匙和推门的操作。

总结来说，一个命令类应该封装一个逻辑上的单一操作，无论这个操作是否由多个步骤组成。这样做有助于保持代码的清晰性和可维护性。如果需要执行多个独立的操作，最好将它们分别封装在不同的命令类中。