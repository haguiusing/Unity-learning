## 责任链模式
责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。
责任链模式通过将多个处理器（处理对象）以链式结构连接起来，使得请求沿着这条链传递，直到有一个处理器处理该请求为止。
责任链模式允许多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求。

模式结构：
- Handler：抽象处理者
- BaseHandler：基础处理者
- ConcreteHandler：具体处理者
- Client：客户端

**主要涉及到以下几个核心角色：**
- **抽象处理者（Handler）:**
    - 定义一个处理请求的接口，通常包含一个处理请求的方法（如 `handleRequest`）和一个指向下一个处理者的引用（后继者）。
- **基础处理者 （Base Handler）：**
	- 一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。
	- 通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。
- **具体处理者（ConcreteHandler）:**
    - 实现了抽象处理者接口，负责处理请求。如果能够处理该请求，则直接处理；否则，将请求传递给下一个处理者。
- **客户端（Client）:**
    - 创建处理者对象，并将它们连接成一条责任链。通常，客户端只需要将请求发送给责任链的第一个处理者，无需关心请求的具体处理过程。

![[Pasted image 20250424231849.png]]

![[2021-chain-of-responsibility.svg]]
- **`AbstractHandler` 抽象处理者类**：定义了处理请求的接口，维护对下一个处理者的引用，并实现了请求的传递逻辑。
- **`ConsoleHandler`、`FileHandler`、`Error_HANDLER` 具体处理者类**：继承自 `AbstractHandler`，实现了具体的日志记录逻辑。
- **`Client` 客户端类**：创建并配置责任链，将请求提交给责任链进行处理。

### 步骤 1：创建抽象处理者类
```csharp
using System;

// 抽象处理者类
public abstract class AbstractHandler
{
    public const int INFO = 1;
    public const int DEBUG = 2;
    public const int ERROR = 3;

    protected int Level;
    protected AbstractHandler NextHandler;

    public void SetNextHandler(AbstractHandler nextHandler)
    {
        NextHandler = nextHandler;
    }

    public void HandleMessage(int level, string message)
    {
        if (Level <= level)
        {
            Write(message);
        }
        if (NextHandler != null)
        {
            NextHandler.HandleMessage(level, message);
        }
    }

    protected abstract void Write(string message);
}
```

### 步骤 2：创建具体处理者类
```csharp
// 具体处理者：控制台记录器
public class ConsoleHandler : AbstractHandler
{
    public ConsoleHandler(int level)
    {
        Level = level;
    }

    protected override void Write(string message)
    {
        Console.WriteLine($"Console::Logger: {message}");
    }
}

// 具体处理者：文件记录器
public class FileHandler : AbstractHandler
{
    public FileHandler(int level)
    {
        Level = level;
    }

    protected override void Write(string message)
    {
        Console.WriteLine($"File::Logger: {message}");
    }
}

// 具体处理者：错误记录器
public class Error_HANDLER : AbstractHandler
{
    public Error_HANDLER(int level)
    {
        Level = level;
    }

    protected override void Write(string message)
    {
        Console.WriteLine($"Error::Logger: {message}");
    }
}
```

### 步骤 3：创建客户端类
```csharp
using System;

public class Client
{
    public static AbstractHandler CreateChain()
    {
        AbstractHandler errorHandler = new Error_HANDLER(AbstractHandler.ERROR);
        AbstractHandler fileHandler = new FileHandler(AbstractHandler.DEBUG);
        AbstractHandler consoleHandler = new ConsoleHandler(AbstractHandler.INFO);

        errorHandler.SetNextHandler(fileHandler);
        fileHandler.SetNextHandler(consoleHandler);

        return errorHandler;
    }

    public static void Main(string[] args)
    {
        AbstractHandler chain = CreateChain();

        chain.HandleMessage(AbstractHandler.INFO, "This is an information.");
        Console.WriteLine();

        chain.HandleMessage(AbstractHandler.DEBUG, "This is a debug level information.");
        Console.WriteLine();

        chain.HandleMessage(AbstractHandler.ERROR, "This is an error information.");
    }
}
```

### 运行结果
```cs
Console::Logger: This is an information.

File::Logger: This is a debug level information
Console::Logger: This is a debug level information

Error::Logger: This is an error information.
File::Logger: This is an error information.
Console::Logger: This is an error information.
```

## 与其他模式的关系
- [责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)、 [命令模式](https://refactoringguru.cn/design-patterns/command)、 [中介者模式](https://refactoringguru.cn/design-patterns/mediator)和[观察者模式](https://refactoringguru.cn/design-patterns/observer)用于处理请求发送者和接收者之间的不同连接方式：
    - _责任链_按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
    - _命令_在发送者和请求者之间建立单向连接。
    - _中介者_清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
    - _观察者_允许接收者动态地订阅或取消接收请求。
    
- [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)通常和[组合模式](https://refactoringguru.cn/design-patterns/composite)结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。
    
- [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)的管理者可使用[命令模式](https://refactoringguru.cn/design-patterns/command)实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。
    还有另外一种实现方式， 那就是请求自身就是一个_命令_对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。
    
- [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)和[装饰模式](https://refactoringguru.cn/design-patterns/decorator)的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。
    [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种_装饰_可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。