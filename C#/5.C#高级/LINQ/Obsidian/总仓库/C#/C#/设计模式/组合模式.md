# 组合模式
组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

模式结构：
- Component：组件
- Leaf：叶子节点
- Composite：复合节点
- Client：客户端

**组合模式的核心角色包括：**
- **抽象根节点/组件（Component）:**
    - 定义了组合中所有对象的通用接口，可以是抽象类或接口。它声明了用于访问和管理子组件的方法，包括添加、删除、获取子组件等。
- **叶子节点（Leaf）:**
    - 表示组合中的叶子节点对象，叶子节点没有子节点。它实现了组件接口的方法，但通常不包含子组件。
- **树枝节点/复合节点（Composite）:**
    - 表示组合中的复合对象，复合节点可以包含子节点，可以是叶子节点，也可以是其他复合节点。它实现了组件接口的方法，包括管理子组件的方法。
- **客户端（Client）:**
    - 通过组件接口与组合结构进行交互，客户端不需要区分叶子节点和复合节点，可以一致地对待整体和部分。

![[Pasted image 20250502153055.png]]

- **`IComponent` 组件接口**：定义了所有组件都需要实现的方法，包括添加子组件、移除子组件、获取子组件、获取员工信息和显示员工信息。
- **`Leaf` 叶子节点类**：实现了 `IComponent` 接口，表示一个叶子节点（即没有子节点的员工）。叶子节点不支持添加和移除子节点的操作。
- **`Composite` 复合节点类**：实现了 `IComponent` 接口，表示一个复合节点（即可以包含子节点的员工）。复合节点维护一个子组件列表，并实现了添加和移除子节点的操作。
- **`CompositePatternDemo` 客户类**：演示了如何使用组合模式来构建和打印一个组织结构。

## 透明组合模式
透明模式：把组合（树节点）使用的方法放到统一行为（Component）中，让不同层次（树节点，[叶子节点](https://so.csdn.net/so/search?q=%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9&spm=1001.2101.3001.7020)）的结构都具备一致行为；其 UML 类图如下所示：
### 步骤 1：创建组件接口
```csharp
using System.Collections.Generic;

// 组件接口
public interface IComponent
{
    void Add(IComponent component);
    void Remove(IComponent component);
    List<IComponent> GetChildren();
    string Name { get; }
    string Dept { get; }
    int Salary { get; }
    void Display(int depth);
}
```

### 步骤 2：创建叶子节点类
```csharp
// 叶子节点类
public class Leaf : IComponent
{
    public string Name { get; private set; }
    public string Dept { get; private set; }
    public int Salary { get; private set; }

    public Leaf(string name, string dept, int salary)
    {
        Name = name;
        Dept = dept;
        Salary = salary;
    }

    public void Add(IComponent component)
    {
        // 叶子节点不支持添加子节点
    }

    public void Remove(IComponent component)
    {
        // 叶子节点不支持移除子节点
    }

    public List<IComponent> GetChildren()
    {
        return new List<IComponent>();
    }

    public void Display(int depth)
    {
        Console.WriteLine(new string(' ', depth * 2) + "Employee :[ Name : " + Name + ", dept : " + Dept + ", salary :" + Salary + " ]");
    }
}
```

### 步骤 3：创建复合节点类
```csharp
using System.Collections.Generic;

// 复合节点类
public class Composite : IComponent
{
    public string Name { get; private set; }
    public string Dept { get; private set; }
    public int Salary { get; private set; }

    private readonly List<IComponent> _children = new List<IComponent>();

    public Composite(string name, string dept, int salary)
    {
        Name = name;
        Dept = dept;
        Salary = salary;
    }

    public void Add(IComponent component)
    {
        _children.Add(component);
    }

    public void Remove(IComponent component)
    {
        _children.Remove(component);
    }

    public List<IComponent> GetChildren()
    {
        return new List<IComponent>(_children);
    }

    public void Display(int depth)
    {
        Console.WriteLine(new string(' ', depth * 2) + "Employee :[ Name : " + Name + ", dept : " + Dept + ", salary :" + Salary + " ]");
        foreach (IComponent child in _children)
        {
            child.Display(depth + 1);
        }
    }
}
```

### 步骤 4：创建客户类
```csharp
using System;

public class CompositePatternDemo
{
    public static void Main(string[] args)
    {
        // 创建 CEO
        IComponent ceo = new Composite("John", "CEO", 30000);

        // 创建部门经理
        IComponent headSales = new Composite("Robert", "Head Sales", 20000);
        IComponent headMarketing = new Composite("Michel", "Head Marketing", 20000);

        // 创建销售部门员工
        IComponent salesExecutive1 = new Leaf("Richard", "Sales", 10000);
        IComponent salesExecutive2 = new Leaf("Rob", "Sales", 10000);

        // 创建市场部门员工
        IComponent clerk1 = new Leaf("Laura", "Marketing", 10000);
        IComponent clerk2 = new Leaf("Bob", "Marketing", 10000);

        // 构建组织结构
        ceo.Add(headSales);
        ceo.Add(headMarketing);

        headSales.Add(salesExecutive1);
        headSales.Add(salesExecutive2);

        headMarketing.Add(clerk1);
        headMarketing.Add(clerk2);

        // 打印组织结构
        ceo.Display(0);
    }
}
```

## 安全组合模式
统一行为（Component）只规定系统各个层次的最基础的一致行为，而把组合（树节点）本身的方法（管理子类对象的添加，删除等）放到自身当中；其 UML 类图如下所示：

![[Pasted image 20250502153806.png]]
### 步骤 1：创建统一行为接口
```csharp
using System.Collections.Generic;

// 统一行为接口
public interface IComponent
{
    string Name { get; }
    string Dept { get; }
    int Salary { get; }
    void Display(int depth);
}
```

### 步骤 2：创建组合类/复合节点类
```csharp
using System.Collections.Generic;

// 组合类
public class Composite : IComponent
{
    public string Name { get; private set; }
    public string Dept { get; private set; }
    public int Salary { get; private set; }

    private readonly List<IComponent> _children = new List<IComponent>();

    public Composite(string name, string dept, int salary)
    {
        Name = name;
        Dept = dept;
        Salary = salary;
    }

    public void Add(IComponent component)
    {
        _children.Add(component);
    }

    public void Remove(IComponent component)
    {
        _children.Remove(component);
    }

    public List<IComponent> GetChildren()
    {
        return new List<IComponent>(_children);
    }

    public void Display(int depth)
    {
        Console.WriteLine(new string(' ', depth * 2) + "Employee :[ Name : " + Name + ", dept : " + Dept + ", salary :" + Salary + " ]");
        foreach (IComponent child in _children)
        {
            child.Display(depth + 1);
        }
    }
}
```

### 步骤 3：创建叶子节点类
```csharp
// 叶子节点类
public class Leaf : IComponent
{
    public string Name { get; private set; }
    public string Dept { get; private set; }
    public int Salary { get; private set; }

    public Leaf(string name, string dept, int salary)
    {
        Name = name;
        Dept = dept;
        Salary = salary;
    }

    public void Display(int depth)
    {
        Console.WriteLine(new string(' ', depth * 2) + "Employee :[ Name : " + Name + ", dept : " + Dept + ", salary :" + Salary + " ]");
    }
}
```

### 步骤 4：创建客户类
```csharp
using System;

public class CompositePatternDemo
{
    public static void Main(string[] args)
    {
        // 创建 CEO
        Composite ceo = new Composite("John", "CEO", 30000);

        // 创建部门经理
        Composite headSales = new Composite("Robert", "Head Sales", 20000);
        Composite headMarketing = new Composite("Michel", "Head Marketing", 20000);

        // 创建销售部门员工
        Leaf salesExecutive1 = new Leaf("Richard", "Sales", 10000);
        Leaf salesExecutive2 = new Leaf("Rob", "Sales", 10000);

        // 创建市场部门员工
        Leaf clerk1 = new Leaf("Laura", "Marketing", 10000);
        Leaf clerk2 = new Leaf("Bob", "Marketing", 10000);

        // 构建组织结构
        ceo.Add(headSales);
        ceo.Add(headMarketing);

        headSales.Add(salesExecutive1);
        headSales.Add(salesExecutive2);

        headMarketing.Add(clerk1);
        headMarketing.Add(clerk2);

        // 打印组织结构
        ceo.Display(0);
    }
}
```

在安全组合模式中，我们只将必要操作定义在接口中，而将组合操作如 `Add`、`Remove` 和 `GetChildren` 放在 `Composite` 类中，使其更加安全。
## 模式选择
既然 组合模式 会被分为两种实现，那么肯定是不同的场合某一种会更加适合，也即具体情况具体分析。

- 透明组合模式 将公共接口封装到抽象根节点（Component）中，那么系统所有节点就具备一致行为，所以如果当系统绝大多数层次具备相同的公共行为时，采用 透明组合模式 也许会更好（代价：为剩下少数层次节点引入不需要的方法）；
- 而如果当系统各个层次差异性行为较多或者树节点层次相对稳定（健壮）时，采用 安全组合模式

注：设计模式的出现并不是说我们要写的代码一定要遵循设计模式所要求的方方面面，这是不现实同时也是不可能的。设计模式的出现，其实只是强调好的代码所具备的一些特征（六大设计原则），这些特征对于项目开发是具备积极效应的，但不是说我们每实现一个类就一定要全部满足设计模式的要求，如果真的存在完全满足设计模式的要求，反而可能存在过度设计的嫌疑。同时，23种设计模式，其实都是严格依循设计模式六大原则进行设计，只是不同的模式在不同的场景中会更加适用。设计模式的理解应该重于意而不是形，真正编码时，经常使用的是某种设计模式的变形体，真正切合项目的模式才是正确的模式。

### 运行结果
```cs
Employee :[ Name : John, dept : CEO, salary :30000 ]
  Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]
    Employee :[ Name : Richard, dept : Sales, salary :10000 ]
    Employee :[ Name : Rob, dept : Sales, salary :10000 ]
  Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]
    Employee :[ Name : Laura, dept : Marketing, salary :10000 ]
    Employee :[ Name : Bob, dept : Marketing, salary :10000 ]
```

## 与其他模式的关系
- [桥接模式](https://refactoringguru.cn/design-patterns/bridge)、 [状态模式](https://refactoringguru.cn/design-patterns/state)和[策略模式](https://refactoringguru.cn/design-patterns/strategy) （在某种程度上包括[适配器模式](https://refactoringguru.cn/design-patterns/adapter)） 模式的接口非常相似。 实际上， 它们都基于[组合模式](https://refactoringguru.cn/design-patterns/composite)——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。
    
- 你可以在创建复杂[组合](https://refactoringguru.cn/design-patterns/composite)树时使用[生成器模式](https://refactoringguru.cn/design-patterns/builder)， 因为这可使其构造步骤以递归的方式运行。
    
- [责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)通常和[组合模式](https://refactoringguru.cn/design-patterns/composite)结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。
    
- 你可以使用[迭代器模式](https://refactoringguru.cn/design-patterns/iterator)来遍历[组合](https://refactoringguru.cn/design-patterns/composite)树。
    
- 你可以使用[访问者模式](https://refactoringguru.cn/design-patterns/visitor)对整个[组合](https://refactoringguru.cn/design-patterns/composite)树执行操作。
    
- 你可以使用[享元模式](https://refactoringguru.cn/design-patterns/flyweight)实现[组合](https://refactoringguru.cn/design-patterns/composite)树的共享叶节点以节省内存。
    
- [组合](https://refactoringguru.cn/design-patterns/composite)和[装饰模式](https://refactoringguru.cn/design-patterns/decorator)的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。
    
    _装饰_类似于_组合_， 但其只有一个子组件。 此外还有一个明显不同： _装饰_为被封装对象添加了额外的职责， _组合_仅对其子节点的结果进行了 “求和”。
    
    但是， 模式也可以相互合作： 你可以使用_装饰_来扩展_组合_树中特定对象的行为。
    
- 大量使用[组合](https://refactoringguru.cn/design-patterns/composite)和[装饰](https://refactoringguru.cn/design-patterns/decorator)的设计通常可从对于[原型模式](https://refactoringguru.cn/design-patterns/prototype)的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。