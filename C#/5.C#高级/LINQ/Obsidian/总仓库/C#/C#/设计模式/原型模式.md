[C#设计模式系列：原型模式（Prototype） - libingql - 博客园](https://www.cnblogs.com/libingql/p/3633377.html)
## 原型模式
原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

模式结构：
- PrototypeInterface：原型抽象类/接口
- ConcretePrototype：具体原型类
- Client：客户端

原型模式包含以下几个主要角色：
- **接口（Prototype Interface）**：定义一个用于克隆自身的接口，通常包括一个 `clone()` 方法。
	-  浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
	-  深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。
- **具体原型类（Concrete Prototype）**：实现原型接口的具体类，负责实际的克隆操作。这个类需要实现 `clone()` 方法，通常使用浅拷贝或深拷贝来复制自身。
- **客户端（Client）**：使用原型实例来创建新的对象。客户端调用原型对象的 `clone()` 方法来创建新的对象，而不是直接使用构造函数。

![[Pasted image 20250424213305.png]]

- **`IPrototype` 原型接口**：定义了克隆方法的接口。
- **`ConcretePrototypeCircle`、`ConcretePrototypeSquare`、`ConcretePrototypeRectangle` 具体原型类**：实现了 `IPrototype` 接口，具体实现了克隆方法和绘图方法。
- **`PrototypeCache` 原型缓存类**：负责管理原型对象的创建和克隆，提供了一个静态方法 `LoadCache` 来初始化缓存，并提供了一个获取原型对象克隆的方法 `GetPrototype`。
- **`Client` 客户端类**：演示了如何使用原型缓存类来获取原型对象的克隆，并调用它们的绘图方法。

### 步骤 1：创建原型接口
```csharp
using System;

// 原型接口
public interface IPrototype
{
    IPrototype Clone();
}
```

### 步骤 2：创建具体原型类
```csharp
// 具体原型类：圆形
public class ConcretePrototypeCircle : IPrototype
{
    public string Id { get; set; }
    public string Type { get; private set; }

    public ConcretePrototypeCircle()
    {
        Type = "Circle";
    }

    public IPrototype Clone()
    {
        return (IPrototype)this.MemberwiseClone();
    }

    public void Draw()
    {
        Console.WriteLine("Inside ConcretePrototypeCircle::Draw() method.");
    }
}

// 具体原型类：正方形
public class ConcretePrototypeSquare : IPrototype
{
    public string Id { get; set; }
    public string Type { get; private set; }

    public ConcretePrototypeSquare()
    {
        Type = "Square";
    }

    public IPrototype Clone()
    {
        return (IPrototype)this.MemberwiseClone();
    }

    public void Draw()
    {
        Console.WriteLine("Inside ConcretePrototypeSquare::Draw() method.");
    }
}

// 具体原型类：矩形
public class ConcretePrototypeRectangle : IPrototype
{
    public string Id { get; set; }
    public string Type { get; private set; }

    public ConcretePrototypeRectangle()
    {
        Type = "Rectangle";
    }

    public IPrototype Clone()
    {
        return (IPrototype)this.MemberwiseClone();
    }

    public void Draw()
    {
        Console.WriteLine("Inside ConcretePrototypeRectangle::Draw() method.");
    }
}
```

### 步骤 3：创建原型缓存类
```csharp
using System.Collections.Generic;

// 原型缓存类
public class PrototypeCache
{
    private static readonly Dictionary<string, IPrototype> prototypeMap = new Dictionary<string, IPrototype>();

    public static void LoadCache()
    {
        ConcretePrototypeCircle circle = new ConcretePrototypeCircle();
        circle.Id = "1";
        prototypeMap.Add(circle.Id, circle);

        ConcretePrototypeSquare square = new ConcretePrototypeSquare();
        square.Id = "2";
        prototypeMap.Add(square.Id, square);

        ConcretePrototypeRectangle rectangle = new ConcretePrototypeRectangle();
        rectangle.Id = "3";
        prototypeMap.Add(rectangle.Id, rectangle);
    }

    public static IPrototype GetPrototype(string prototypeId)
    {
        if (prototypeMap.TryGetValue(prototypeId, out IPrototype prototype))
        {
            return prototype.Clone();
        }
        return null;
    }
}
```

### 步骤 4：创建客户端类
```csharp
// 客户端类
public class Client
{
    public static void Main(string[] args)
    {
        PrototypeCache.LoadCache();

        IPrototype prototype1 = PrototypeCache.GetPrototype("1");
        Console.WriteLine("Shape : " + prototype1.GetType().Name);

        IPrototype prototype2 = PrototypeCache.GetPrototype("2");
        Console.WriteLine("Shape : " + prototype2.GetType().Name);

        IPrototype prototype3 = PrototypeCache.GetPrototype("3");
        Console.WriteLine("Shape : " + prototype3.GetType().Name);

        // 测试克隆对象的独立性
        Console.WriteLine("\nTesting cloned objects:");
        (prototype1 as ConcretePrototypeCircle).Draw();
        (prototype2 as ConcretePrototypeSquare).Draw();
        (prototype3 as ConcretePrototypeRectangle).Draw();
    }
}
```

### 运行结果：
```
Shape : ConcretePrototypeCircle
Shape : ConcretePrototypeSquare
Shape : ConcretePrototypeRectangle

Testing cloned objects:
Inside ConcretePrototypeCircle::Draw() method.
Inside ConcretePrototypeSquare::Draw() method.
Inside ConcretePrototypeRectangle::Draw() method.
```

MemberwiseClone()即为浅复制。如果字段是值类型的，则对字段执行逐位复制，如果字段是引用类型的，则复制对象的引用，而不复制对象，因此：原始对象和其副本引用同一个对象！

深拷贝：
1. 第一种实现方式 new
```cs
class People
{
    public int _age;
    public string _name;
    public People(int Age,string Name)
    {
        _age = Age;
　　　　 _name = Name;
    }

    public object Clone()
    {
        People MySelf = new People(this._age,this._name);
        return MySelf;    }
}
```

2. 第二种实现方式 Clone
```cs
this.v = (int[])v.Clone();
```

3. 第三种实现方式 序列化和反序列号
```cs
class Program
    {
        static void Main(string[] args)
        {
            Person p = new Person() { 
                Age=12, 
                Name="张三" ,
                Address = new Address()
                {
                    Provice = "上海",
                    City = "上海市"
                }
           };

            //浅拷贝
            Person p2 = (Person)p.Clone();
            p2 .UserName = "浅拷贝用户名";
            p2 .Address.Provice = "浅拷贝上海";
            
           //通过序列化、反序列化实现深拷贝
            Person p3= JsonConvert.DesperializeObject<Person>(JsonConvert.SerializeObject(p));
            p3.UserName = "深拷贝用户名";
            p3.Address.Provice = "深拷贝上海";
        }
    }

    public class Address
    {
        public string Provice { get; set; }
 
        public string City { get; set; }
    }

    public class Person:System.ICloneable
    {
        public string Name { get; set; }
        public int Age { get; set; }

        public object Clone()
        {
            return this.MemberwiseClone();
        }
    }
```

##  与其他模式的关系
- 在许多设计工作的初期都会使用[工厂方法模式](https://refactoringguru.cn/design-patterns/factory-method) （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用[抽象工厂模式](https://refactoringguru.cn/design-patterns/abstract-factory)、 [原型模式](https://refactoringguru.cn/design-patterns/prototype)或[生成器模式](https://refactoringguru.cn/design-patterns/builder) （更灵活但更加复杂）。
    
- [抽象工厂模式](https://refactoringguru.cn/design-patterns/abstract-factory)通常基于一组[工厂方法](https://refactoringguru.cn/design-patterns/factory-method)， 但你也可以使用[原型模式](https://refactoringguru.cn/design-patterns/prototype)来生成这些类的方法。
    
- [原型](https://refactoringguru.cn/design-patterns/prototype)可用于保存[命令模式](https://refactoringguru.cn/design-patterns/command)的历史记录。
    
- 大量使用[组合模式](https://refactoringguru.cn/design-patterns/composite)和[装饰模式](https://refactoringguru.cn/design-patterns/decorator)的设计通常可从对于[原型](https://refactoringguru.cn/design-patterns/prototype)的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。
    
- [原型](https://refactoringguru.cn/design-patterns/prototype)并不基于继承， 因此没有继承的缺点。 另一方面， _原型_需要对被复制对象进行复杂的初始化。 [工厂方法](https://refactoringguru.cn/design-patterns/factory-method)基于继承， 但是它不需要初始化步骤。
    
- 有时候[原型](https://refactoringguru.cn/design-patterns/prototype)可以作为[备忘录模式](https://refactoringguru.cn/design-patterns/memento)的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。
    
- [抽象工厂](https://refactoringguru.cn/design-patterns/abstract-factory)、 [生成器](https://refactoringguru.cn/design-patterns/builder)和[原型](https://refactoringguru.cn/design-patterns/prototype)都可以用[单例模式](https://refactoringguru.cn/design-patterns/singleton)来实现。