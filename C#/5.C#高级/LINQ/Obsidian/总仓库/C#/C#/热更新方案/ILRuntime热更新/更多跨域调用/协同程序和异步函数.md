主入口：![[ILRuntimeMain.cs]]
![[Lesson16.cs]]
![[CoroutineAdapter.cs]]
![[IAsyncStateMachineClassInheritanceAdaptor.cs]]

### 在ILRuntime热更工程中使用协同程序
注册协同程序的跨域继承适配器，可以在示例工程中获取。

在热更工程主入口声明协程并执行
```cs
public static IEnumerator Lesson17Courtinue()
{
    Debug.Log(0);
    yield return new WaitForSeconds(1f);

    Debug.Log(1);
    yield return new WaitForSeconds(1f);

    Debug.Log(2);
    yield return new WaitForSeconds(1f);

    Debug.Log(3);
    yield return new WaitForSeconds(1f);
}

Lesson17_更多跨域调用_协同程序和异步函数 lesson17 = GameObject.FindObjectOfType<Lesson17_更多跨域调用_协同程序和异步函数>();
lesson17.StartCoroutine(Lesson17Courtinue());
```

重新生成后再Unity会报错，TypeLoadException: Cannot find Adaptor，不能找到协程适配器

![[Pasted image 20250603164117.png]]
示例代码中提供了协程适配器，找到CoroutineAdapter类，在ILruntime管理器直接注册就可以正常使用协程。
```cs
//注册协程跨域适配器
appDomain.RegisterCrossBindingAdaptor(new CoroutineAdapter());
```

### 在ILRuntime热更工程中使用异步函数
注册异步函数的跨域继承适配器，可以获取别人写好的异步函数跨域适配器。若无法访问，可以在资料区下载该文件。

导入别人写好的异步适配器IAsyncStateMachineClassInheritanceAdaptor

在热更工程定义异步函数，并调用。重新生成后再Unity运行也会报错。
```cs
public static async void Lesson17Async()
{
    Debug.Log("Lesson17Async 1");
    await Task.Delay(1000);

    Debug.Log("Lesson17Async 2");
    await Task.Delay(1000);

    Debug.Log("Lesson17Async 3");
    await Task.Delay(1000);

    Debug.Log("Lesson17Async 4");
    await Task.Delay(1000);
}

Lesson17Async();
```

在ILruntime注册异步适配器后可以正常运行
```cs
//注册异步跨域适配器
appDomain.RegisterCrossBindingAdaptor(new IAsyncStateMachineClassInheritanceAdaptor());
```

### 总结
之所以需要注册跨域继承适配器，是因为在ILRuntime中的协同程序和异步函数编译后本质上是通过状态机利用对象的状态来达到的异步。这里面的对象就用到了跨域继承，所以我们需要注册他们的跨域继承适配器来让热更新工程正常使用他们。