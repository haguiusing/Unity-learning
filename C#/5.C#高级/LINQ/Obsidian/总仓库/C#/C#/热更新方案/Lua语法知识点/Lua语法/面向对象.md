[面向对象](file:///D:/Unity%20Lua/Lua%E8%AF%AD%E6%B3%95/Lua%E8%AF%AD%E6%B3%95/Lesson15_OO.lua)
[面向对象_ALL](file:///D:/Unity%20Lua/Lua%E8%AF%AD%E6%B3%95/Lua%E8%AF%AD%E6%B3%95/Lesson15_OO_All.lua)

## 封装
![[Pasted image 20250529130840.png]]
面向对象 类 其实都是基于 table来实现
封装通常通过将数据和方法封装在一个表中实现。我们可以通过控制表的访问权限来模拟封装，例如使用 metamethods 来限制外部访问。
```lua
-- 定义一个"类"（实际上是一个表）和一个属性id
Object = {}
Object.id = 1

function Object:Test()
	print(self.id)
end

-- 添加封装：隐藏属性
--冒号 是会自动将调用这个函数的对象 作为第一个参数传入的写法
function Object:new()
	--self 代表的是 我们默认传入的第一个参数
	--对象就是变量 返回一个新的变量
	--返回出去的内容 本质上就是表对象
	local obj = {}
	--元表知识 __index 当找自己的变量 找不到时 就会去找元表当中__index指向的内容
	self.__index = self
	setmetatable(obj, self)
	obj.name = name
    obj.age = age
	return obj
end

function Object:setName(name)
    self.name = name  -- 提供方法来修改 name
end

function Object:getName()
    return self.name  -- 提供方法来获取 name
end

local myObj = Object:new()
print(myObj) --table: 00BA9B18 
--调用Object:new()，self为Object，myObj = 返回值obj 即以Object为元表的obj表
print(myObj.id)  --1
myObj:Test()  --1
--对空表中 local obj = {} 申明一个新的属性 叫做id
myObj.id = 2  
print(myObj.id)  --2 存在myObj中
print(Object.id)  --1
myObj:Test()  --2 传入myObj

myObj:setName("名字1")
myObj.name = "名字2"
print(myObj.name)  --名字2
print(myObj.getName)  --function: 00A2C028
print(myObj:getName())    --名字2
```

### 使用元方法限制外部访问
```lua
-- 定义一个表
local myTable = {}

-- 定义一个元表
local metaTable = {
    -- 控制读取访问
    __index = function(table, key)
        error("无法访问：" .. tostring(key))
    end,
    -- 控制写入访问
    __newindex = function(table, key, value)
        error("无法修改：" .. tostring(key))
    end,
    -- 防止获取元表
    __metatable = "保护的元表"
}

-- 设置元表
setmetatable(myTable, metaTable)

-- 尝试访问表中的字段
print(myTable.someField) -- 触发 __index，输出错误信息

-- 尝试修改表中的字段
myTable.someField = "新值" -- 触发 __newindex，输出错误信息

-- 尝试获取元表
print(getmetatable(myTable)) -- 输出 "保护的元表"
```
#### 限制访问的具体场景
1. **只读表** ：通过 `__newindex` 元方法，可以防止外部对表进行修改，从而实现只读表。
2. **隐藏字段** ：通过 `__index` 元方法，可以隐藏表中的某些字段，防止外部直接访问。
3. **访问控制** ：可以根据特定的条件或权限，允许或拒绝对外部的访问。

#### 只读表示例
```lua
-- 创建一个只读表
local readOnlyTable = {}
local data = { key = "value" }

local metaTable = {
    __index = function(_, key)
        return data[key]
    end,
    __newindex = function(_, key, value)
        error("无法修改只读表")
    end
}

setmetatable(readOnlyTable, metaTable)

-- 读取字段
print(readOnlyTable.key) -- 输出 "value"

-- 修改字段
readOnlyTable.key = "新值" -- 触发错误
```
#### 隐藏字段示例
```lua
-- 创建一个表
local myTable = {
    publicField = "公开字段",
    _privateField = "私有字段"
}

local metaTable = {
    __index = function(table, key)
        if key:match("^_") then
            error("无法访问私有字段：" .. key)
        end
        return rawget(table, key)
    end
}

setmetatable(myTable, metaTable)

-- 访问公开字段
print(myTable.publicField) -- 输出 "公开字段"

-- 访问私有字段
print(myTable._privateField) -- 触发错误
```

## 继承
通过元表（metatable）和元方法（metamethod）来实现继承。创建一个新表，并将其元表设置为父类。
具体步骤如下：
1. 创建一个基类（父类）表。
2. 创建一个子类表。
3. 设置子类的元表为基类表。
4. 使用 `__index` 元方法来实现继承。
### 实现方法1——调用父类的构造函数来继承父类的属性和方法。
这种方式是直接利用基类的构造函数来创建子类，子类继承基类的属性和方法。
```lua
-- 基类
BaseClass = {}
function BaseClass:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    return o
end

function BaseClass:printName()
    print("BaseClass")
end

-- 子类
SubClass = BaseClass:new()

function SubClass:printName()
    print("SubClass")
end

-- 创建子类实例
local instance = SubClass:new()
instance:printName()  -- 输出: SubClass
```

`Square` 类通过调用 `Rectangle:new()` 创建，这使得 `Square` 继承了 `Rectangle` 的属性和方法。
```lua
-- 定义矩形类  
Rectangle = {area = 0, length = 0, breadth = 0}  
  
-- 创建矩形对象的构造函数  
function Rectangle:new(o, length, breadth) 
  o = o or {}  -- 如果未传入对象，创建一个新的空表  
  setmetatable(o, self)  -- 设置元表，使其继承 Rectangle 的方法  
  self.__index = self  -- 确保在访问时能找到方法和属性  
  o.length = length or 0  -- 设置长度，默认为 0  
  o.breadth = breadth or 0  -- 设置宽度，默认为 0  
  o.area = o.length * o.breadth  -- 计算面积  
  return o  
end  
  
-- 打印矩形的面积  
function Rectangle:printArea()  
  print("矩形面积为 ", self.area)  
end  
  
-- 定义正方形类，继承自矩形类  
Square = Rectangle:new()  -- Square 继承 Rectangle 类  
  
-- 重写构造函数（正方形的边长相等）  
function Square:new(o, side)  
  o = o or {}  -- 如果未传入对象，创建一个新的空表  
  setmetatable(o, self)  -- 设置元表，使其继承 Rectangle 的方法  
  self.__index = self  -- 确保在访问时能找到方法和属性  
  o.length = side or 0  -- 设置边长  
  o.breadth = side or 0  -- 正方形的宽度和长度相等  
  o.area = o.length * o.breadth  -- 计算面积  
  return o  
end  
  
-- 运行实例：  
local rect = Rectangle:new(nil, 5, 10)  -- 创建一个长为 5，宽为 10 的矩形  
rect:printArea()  -- 输出 "矩形面积为 50"  
  
local square = Square:new(nil, 4)  -- 创建一个边长为 4 的正方形  
square:printArea()  -- 输出 "矩形面积为 16"
```
**特点**：
- 简单直接，适合单层继承。
- 子类可以重写构造函数以适应其特定需求（如正方形的边长相等）。
### 实现方法2——创建子类，定义子类与父类之间的继承关系
```lua
-- 基类Object 定义一个"类"（实际上是一个表）和一个属性id
Object = {}
Object.id = 1

function Object:Test()
	print(self.id)
end

-- 添加封装：隐藏属性
--冒号 是会自动将调用这个函数的对象 作为第一个参数传入的写法
function Object:new()
	--self 代表的是 我们默认传入的第一个参数
	--对象就是变量 返回一个新的变量
	--返回出去的内容 本质上就是表对象
	local obj = {}
	--元表知识 __index 当找自己的变量 找不到时 就会去找元表当中__index指向的内容
	self.__index = self
	setmetatable(obj, self)
	return obj
end

--写一个用于继承的方法 Object为基类
function Object:subClass(className)
	-- _G知识点 是总表 所有声明的全局标量 都以键值对的形式存在其中
	-- 在全局表 _G 中创建一个新类
	_G[className] = {}
	local obj = _G[className]
	--写相关继承的规则
	--用到元表

	--设置元表的 __index 为当前类，以便子类可以访问父类的方法和属性
	self.__index = self
	--子类 定义个base属性 base属性代表父类
	obj.base = self
	-- 设置子类的元表为父类
	setmetatable(obj, self)
end

Object:subClass("Person")  --子类 Person

local p1 = Person:new()
print(p1.id)  -- 输出 1（继承自 Object）
p1.id = 100
print(p1.id)  -- 输出 100（覆盖了继承的 id）
p1:Test()     -- 输出 100（调用父类的 Test 方法）

Object:subClass("Monster")  --子类 Monster
local m1 = Monster:new()
print(m1.id)  -- 输出 1（继承自 Object）
m1.id = 200
print(m1.id)  -- 输出 200（覆盖了继承的 id）
m1:Test()     -- 输出 200（调用父类的 Test 方法）
```

改进后的 `subClass` 方法：
```lua
function Object:subClass(className)
    -- 在全局表 _G 中创建一个新类
    _G[className] = {}
    local obj = _G[className]

    -- 设置元表的 __index 为父类，以便子类可以访问父类的方法和属性
    local meta = { __index = self }
    setmetatable(obj, meta)

    -- 子类的 base 属性指向父类，用于显式访问父类的方法和属性
    obj.base = self

    -- 返回子类
    return obj
end
```

都是通过父类的构造函数来创建子类，可选重写构造函数

## 多态
多态性通过元表和方法重写实现。当不同类型的对象调用相同的方法时，Lua 会根据对象的实际类型执行不同的方法。
```lua
-- 定义一个基类
local Animal = {}
Animal.__index = Animal

function Animal:new(name)
    local obj = {name = name}
    setmetatable(obj, self)
    return obj
end

function Animal:speak()
    print("Animal sound")
end

-- 定义子类 Dog
local Dog = Animal:new()

function Dog:speak()
    print(self.name .. " says Woof!")
end

-- 定义子类 Cat
local Cat = Animal:new()

function Cat:speak()
    print(self.name .. " says Meow!")
end

-- 使用多态
local animals = {
    Dog:new("Buddy"),
    Cat:new("Whiskers")
}

for _, animal in ipairs(animals) do
    animal:speak()
end

输出结果：
Buddy says Woof!
Whiskers says Meow!
```

```lua
--相同行为 不同表象 就是多态
--相同方法 不同执行逻辑 就是多态
Object:subClass("GameObject")
GameObject.posX = 0;
GameObject.posY = 0;
function GameObject:Move()
	self.posX = self.posX + 1
	self.posY = self.posY + 1
	print(self.posX .." ".. self.posY)
	--print("GameObject")
end

GameObject:subClass("Player")
function Player:Move()
	print("Player")

	--base 指的是 GameObject 表（类）
	--这种方式调用 相当于是把基类表 作为第一个参数传入了方法中
	--避免把基类表 传入到方法中 这样相当于就是公用一张表的属性了
	--self.base:Move()
	--我们如果要执行父类逻辑 我们不要直接使用冒号调用
	--要通过.调用 然后自己传入第一个参数 
	self.base.Move(self)
end

local p1 = Player:new()
p1:Move()  --1  1
p1:Move()  --2  2
--目前这种写法 有坑 不同对象使用的成员变量 居然是相同的成员变量
--不是自己的
local p2 = Player:new()
p2:Move()  --1  1
```