![[Lesson37 2.cs]]
![[GenerateCSharp 2.cs]]
![[ProtocolInfo 1.xml]]
![[ProtocolTool 2.cs]]
![[ProtobufTool.cs]]

### 对比消息类和数据结构类的不同
#### **类名和继承**
```cs
public class PlayerMessage : BaseMessage
```
#### **获得字节数组方法多了消息ID长度和消息体长度8个字节**
```cs
public override int GetBytesNum()
{
    return 
        4 + // 消息ID的长度
        4 + // 消息体的长度
        4 + // playerID的字节数组长度
        playerData.GetBytesNum(); // playerData的字节数组长度
}
```
#### **序列化方法要先写消息ID再写消息体长度**
```cs
public override byte[] Writing()
{
    int index = 0;

    int bytesNum = GetBytesNum();

    byte[] bytes = new byte[bytesNum];
    // 先写消息ID
    WriteInt(bytes, GetID(), ref index);

    // 写入消息体的长度
    WriteInt(bytes, bytesNum - 8, ref index);

    // 写这个消息的成员变量
    WriteInt(bytes, playerID, ref index);
    WriteData(bytes, playerData, ref index);
    return bytes;
}
```

#### **反序列化由于我们是在外部解析消息ID和消息体长度的，所以和数据结构类一致**
#### **获得定义消息ID的方法**
```cs
/// <summary>
/// 自定义的消息ID 主要用于区分是哪一个消息类
/// </summary>
/// <returns></returns>
public override int GetID()
{
    return 1001;
}
```
### 观察xml配置
```xml
- <!--消息类类配置规则 包含 消息ID 类名 命名空间 变量类型 变量名-->
<message id="1001" name="PlayerMessage" namespace="GamePlayer">
    <field type="int" name="playerID"/>
    <field type="PlayerData" name="data"/>
</message>
<message id="1002" name="HeartMessage" namespace="GameSystem"/>
```

### 在GenerateCSharp类中定义生成消息类方法，并在ProtocolTool中调用
```cs
[MenuItem("ProtocolTool/生成C#脚本")]
private static void GenerateCSharp()
{
    // 读取xml相关的信息
    // XmlNodeList list = GetNodes("enum");
    // 根据这些信息 去拼接字符串 生成对应的脚本
    // 生成对应的枚举脚本
    generateCSharp.GenerateEnum(GetNodes("enum"));
    // 生成对应的数据结构类脚本
    generateCSharp.GenerateData(GetNodes("data"));
    // 生成对应的消息类脚本
    generateCSharp.GenerateMsg(GetNodes("message"));

    // 刷新编辑器界面 让我们可以看到生成的内容 不需要手动进行刷新了
    AssetDatabase.Refresh();
}
```

### 实现生成消息类方法，可以在生产数据结构类方法的基础上改
```cs
// 生成消息类
public void GenerateMsg(XmlNodeList nodes)
{
    string idStr = "";
    string namespaceStr = "";
    string classNameStr = "";
    string fieldStr = "";
    string getBytesNumStr = "";
    string writingStr = "";
    string readingStr = "";

    foreach (XmlNode dataNode in nodes)
    {
        // 消息ID
        idStr = dataNode.Attributes["id"].Value;
        // 命名空间
        namespaceStr = dataNode.Attributes["namespace"].Value;
        // 类名
        classNameStr = dataNode.Attributes["name"].Value;
        // 读取所有字段节点
        XmlNodeList fields = dataNode.SelectNodes("field");
        // 通过这个方法进行成员变量声明的拼接 返回拼接结果
        fieldStr = GetFieldStr(fields);
        // 通过某个方法 对GetBytesNum函数中的字符串内容进行拼接 返回结果
        getBytesNumStr = GetGetBytesNumStr(fields);
        // 通过某个方法 对Writing函数中的字符串内容进行拼接 返回结果
        writingStr = GetWritingStr(fields);
        // 通过某个方法 对Reading函数中的字符串内容进行拼接 返回结果
        readingStr = GetReadingStr(fields);

        string dataStr = "using System;\r\n" +
                         "using System.Collections.Generic;\r\n" +
                         "using System.Text;\r\n" +
                         $"namespace {namespaceStr}\r\n" +
                         "{\r\n" +
                         $"\tpublic class {classNameStr} : BaseMessage\r\n" +
                         "\t{\r\n" +
                         $"{fieldStr}" +
                         "\t\tpublic override int GetBytesNum()\r\n" +
                         "\t\t{\r\n" +
                         "\t\t\tint num = 8;\r\n" + // 这个8代表的是 消息ID的4个字节 + 消息体长度的4个字节
                         $"{getBytesNumStr}" +
                         "\t\t\treturn num;\r\n" +
                         "\t\t}\r\n" +
                         "\t\tpublic override byte[] Writing()\r\n" +
                         "\t\t{\r\n" +
                         "\t\t\tint index = 0;\r\n" +
                         "\t\t\tbyte[] bytes = new byte[GetBytesNum()];\r\n"

 +
                         "\t\t\tWriteInt(bytes, GetID(), ref index);\r\n" +
                         "\t\t\tWriteInt(bytes, bytes.Length - 8, ref index);\r\n" +
                         $"{writingStr}" +
                         "\t\t\treturn bytes;\r\n" +
                         "\t\t}\r\n" +
                         "\t\tpublic override int Reading(byte[] bytes, int beginIndex = 0)\r\n" +
                         "\t\t{\r\n" +
                         "\t\t\tint index = beginIndex;\r\n" +
                         $"{readingStr}" +
                         "\t\t\treturn index - beginIndex;\r\n" +
                         "\t\t}\r\n" +
                         "\t\tpublic override int GetID()\r\n" +
                         "\t\t{\r\n" +
                         "\t\t\treturn " + idStr + ";\r\n" +
                         "\t\t}\r\n" +
                         "\t}\r\n" +
                         "}";

        // 保存为 脚本文件
        // 保存文件的路径
        string path = SAVE_PATH + namespaceStr + "/Msg/";
        // 如果不存在这个文件夹 则创建
        if (!Directory.Exists(path))
            Directory.CreateDirectory(path);

        // 字符串保存 存储为枚举脚本文件
        File.WriteAllText(path + classNameStr + ".cs", dataStr);
    }
    Debug.Log("消息类生成结束");
}
```

### 查看生成的消息类并测试
```cs
using System;
using System.Collections.Generic;
using System.Text;
namespace GamePlayer
{
    public class PlayerMessage : BaseMsg
    {
        public int playerID;
        public PlayerData data;
        public override int GetBytesNum()
        {
            int num = 8;
            num += 4;
            num += data.GetBytesNum();
            return num;
        }
        public override byte[] Writing()
        {
            int index = 0;
            byte[] bytes = new byte[GetBytesNum()];
            WriteInt(bytes, GetID(), ref index);
            WriteInt(bytes, bytes.Length - 8, ref index);
            WriteInt(bytes, playerID, ref index);
            WriteData(bytes, data, ref index);
            return bytes;
        }
        public override int Reading(byte[] bytes, int beginIndex = 0)
        {
            int index = beginIndex;
            playerID = ReadInt(bytes, ref index);
            data = ReadData<PlayerData>(bytes, ref index);
            return index - beginIndex;
        }
        public override int GetID()
        {
            return 1001;
        }
    }
}

using System;
using System.Collections.Generic;
using System.Text;
namespace GameSystem
{
    public class HeartMessage : BaseMsg
    {
        public override int GetBytesNum()
        {
            int num = 8;
            return num;
        }
        public override byte[] Writing()
        {
            int index = 0;
            byte[] bytes = new byte[GetBytesNum()];
            WriteInt(bytes, GetID(), ref index);
            WriteInt(bytes, bytes.Length - 8, ref index);
            return bytes;
        }
        public override int Reading(byte[] bytes, int beginIndex = 0)
        {
            int index = beginIndex;
            return index - beginIndex;
        }
        public override int GetID()
        {
            return 1002;
        }
    }
}

GamePlayer.PlayerMessage playerMessage1 = new GamePlayer.PlayerMessage();
playerMessage1.playerID = 999;
playerMessage1.data = new GamePlayer.PlayerData();
playerMessage1.data.id = 888;
playerMessage1.data.atk = 10;
playerMessage1.data.sex = true;
playerMessage1.data.lev = 77;
playerMessage1.data.arrays = new int[] { 1, 2, 3, 4 };
playerMessage1.data.list = new List<int>() { 4, 3, 2, 1 };
playerMessage1.data.dic = new Dictionary<int, string>() {
    { 1, "123"},
    { 2, "韬老狮"},
    { 3, "好好学习"},
};
playerMessage1.data.heroType = GamePlayer.E_HERO_TYPE.MAIN;

// 序列化
byte[] bytes = playerMessage1.Writing();

// 反序列化
int index = 0;
int msgID = BitConverter.ToInt32(bytes, index);
index += 4;
int msgLength = BitConverter.ToInt32(bytes, index);
index += 4;
GamePlayer.PlayerMessage playerMessage2 = new GamePlayer.PlayerMessage();
playerMessage2.Reading(bytes, index);
print(playerMessage2.playerID);
```