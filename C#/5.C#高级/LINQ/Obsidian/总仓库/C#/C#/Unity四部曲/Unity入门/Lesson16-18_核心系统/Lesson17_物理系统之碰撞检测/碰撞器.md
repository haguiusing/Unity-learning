# 1.3D碰撞器种类
# Box Collider component reference

**盒型碰撞体 (Box Collider)** 是一种基本的长方体形状原始碰撞体。

![](https://docs.unity.cn/cn/2021.3/uploads/Main/Inspector-BoxCollider.png)

## 属性

|**_属性：_**|**_功能：_**|
|---|---|
|**Is Trigger**|如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略。|
|**Material**|引用[物理材质](https://docs.unity.cn/cn/2021.3/Manual/class-PhysicMaterial.html)，可确定该碰撞体与其他对象的交互方式。|
|**Center**|碰撞体在对象局部空间中的位置。|
|**Size**|碰撞体在 X、Y、Z 方向上的大小。|

## 详细信息

盒型碰撞体是可用于板条箱或木箱的长方体。但是，可以使用薄形盒体作为地板、墙壁或坡道。盒型碰撞体也是[复合碰撞体](https://docs.unity.cn/cn/2021.3/Manual/CollidersOverview.html#CompoundColliders)中的有用元素。

要编辑盒体的形状，请按 **Inspector** 中的 Edit Collider 按钮。要退出碰撞体编辑模式，请再次按 Edit Collider 按钮。在编辑模式下，盒型碰撞体每个面的中心位置会出现一个顶点。要移动顶点，请在鼠标悬停在顶点上时拖动顶点以使盒型碰撞体变大或变小。

# Sphere Collider component reference

**球形碰撞体 (Sphere Collider)** 是一种基本的球体形状原始碰撞体。

![](https://docs.unity.cn/cn/2022.2/uploads/Main/Inspector-SphereCollider.png)

## 属性

|**_属性：_**|**_功能：_**|
|---|---|
|**Is Trigger**|如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略。|
|**Material**|引用[物理材质](https://docs.unity.cn/cn/2022.2/Manual/class-PhysicMaterial.html)，可确定该碰撞体与其他对象的交互方式。|
|**Center**|碰撞体在对象局部空间中的位置。|
|**Radius**|碰撞体的大小。|

## 详细信息

可以通过 **Radius** 属性调整碰撞体的大小，但不能单独沿三个轴缩放（即，不能将球体展平为椭圆）。除了网球等球形对象的明显用途外，球体也适用于坠落的巨石和其他需要翻滚的对象。
# Capsule Collider component reference

**胶囊碰撞体 (Capsule Collider)** 由两个半球与一个圆柱体连接在一起组成。胶囊碰撞体与胶囊原始碰撞体的形状相同。

![](https://docs.unity.cn/cn/2022.2/uploads/Main/Inspector-CapsuleCollider.png)

## 属性

|**_属性：_**|**_功能：_**|
|---|---|
|**Is Trigger**|如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略。|
|**Material**|引用[物理材质](https://docs.unity.cn/cn/2022.2/Manual/class-PhysicMaterial.html)，可确定该碰撞体与其他对象的交互方式。|
|**Center**|碰撞体在对象局部空间中的位置。|
|**Radius**|碰撞体的局部宽度的半径。|
|**Height**|碰撞体的总高度。|
|**Direction**|胶囊体在对象局部空间中纵向方向的轴。|

## 详细信息

可以独立调整胶囊碰撞体的 **Radius** 和 **Height**。胶囊碰撞体在[角色控制器](https://docs.unity.cn/cn/2022.2/Manual/class-CharacterController.html)中用于模拟杆体，也可与其他碰撞体组合用于表现不寻常的形状。

![标准胶囊碰撞体](https://docs.unity.cn/cn/2022.2/uploads/Main/CapsuleColliderDiagram.svg)

标准胶囊碰撞体
# Terrain Collider component reference

**地形碰撞体 (Terrain Collider)** 实现了一个碰撞表面，其形状与其所附加到的 [Terrain](https://docs.unity.cn/cn/2022.2/Manual/script-Terrain.html) 对象相同。

![](https://docs.unity.cn/cn/2022.2/uploads/Main/Inspector-TerrainCollider.png)

## 属性

|**_属性：_**|**_功能：_**|
|---|---|
|**Material**|引用[物理材质](https://docs.unity.cn/cn/2022.2/Manual/class-PhysicMaterial.html)，可确定该碰撞体与其他对象的交互方式。|
|**Terrain Data**|地形数据。|
|**Enable Tree Colliders**|选中此属性时，将启用树碰撞体。|

## 详细信息

应注意，Unity 5.0 之前的版本中，地形碰撞体具有 **Smooth Sphere Collisions** 属性，用于改善地形和球体之间的相互作用。此属性现已废弃，因为平滑交互是物理引擎的标准行为，将其关闭没有特别的优势。
# Wheel Collider component reference

**车轮碰撞体 (Wheel Collider)** 是一种用于地面交通工具的特殊碰撞体。此碰撞体内置了碰撞检测、车轮物理组件和基于打滑的轮胎摩擦模型。此碰撞体可以用于除车轮以外的其他对象，但专门设计用于有轮的交通工具。

![](https://docs.unity.cn/cn/2022.2/uploads/Main/Inspector-WheelCollider2.png)

有关使用车轮碰撞体的指南，请参阅 [Unity 车轮碰撞体教程](https://docs.unity.cn/cn/2022.2/Manual/WheelColliderTutorial.html)。

## 属性

|**_属性：_**|**_功能：_**|
|---|---|
|**Mass**|车轮的质量。|
|**Radius**|车轮的半径。|
|**Wheel Damping Rate**|这是应用于车轮的阻尼值。|
|**Suspension Distance**|车轮悬架的最大延伸距离（在局部空间中测量）。悬架始终向下延伸穿过局部 Y 轴。|
|**Force App Point Distance**|此参数定义车轮上的受力点。此距离应该是距车轮底部静止位置的距离（沿悬架行程方向），以米为单位。当 `forceAppPointDistance = 0` 时，受力点位于静止的车轮底部。较好的车辆会使受力点略低于车辆质心。|
|**Center**|车轮在对象局部空间中的中心位置。|
|**Suspension Spring**|悬架尝试通过增加弹簧力和阻尼力来到达__目标位置 (Target Position)**。 \| \|**        Spring__|弹簧力尝试到达__目标位置**。值越大，悬架达到__目标位置__就越快。 \| \|**        Damper__|抑制悬架速度。值越大，__悬架弹簧__移动就越慢。|
|**Target Position**|悬架沿悬架距离 (Suspension Distance) 的静止距离。1 对应于完全展开的悬架，0 对应于完全压缩的悬架。默认值为 0.5，与常规汽车的悬架行为匹配。|
|**Forward/Sideways Friction**|车轮向前和侧向滚动时轮胎摩擦的特性。请参阅下面的_车轮摩擦曲线_部分。|

![车轮碰撞体 (Wheel Collider) 组件。汽车模型由 ATI Technologies Inc. 提供](https://docs.unity.cn/cn/2022.2/uploads/Main/Inspector-WheelCollider.jpg)

车轮碰撞体 (Wheel Collider) 组件。汽车模型由 ATI Technologies Inc. 提供

## 详细信息

通过从__中心 (Center)__ 向下穿过局部 Y 轴进行射线投射来执行车轮的碰撞检测。车轮具有__半径 (Radius)**，并且根据__悬架距离 (Suspension Distance)** 向下延伸。通过脚本使用不同属性来控制车辆，这些属性包括：__motorTorque**、**brakeTorque__ 和 **steerAngle**。有关更多信息，请参阅[车轮碰撞体脚本参考](https://docs.unity.cn/cn/2022.2/ScriptReference/WheelCollider.html)。

车轮碰撞体使用基于打滑的摩擦模型计算摩擦力（独立于物理引擎的其余部分）。这样可以实现更逼真的行为，但也会导致车轮碰撞体忽略标准[物理材质](https://docs.unity.cn/cn/2022.2/Manual/class-PhysicMaterial.html)设置。

### Wheel collider setup

不必通过转动或滚动 WheelCollider 对象来控制汽车；附加了 WheelCollider 的对象应始终相对于汽车本身固定。但是，可能希望转动并滚动图形化的车轮表示。最好的方法是为车轮碰撞体和可见车轮设置单独的对象：

![车轮碰撞体 (Wheel Colliders) 与可见车轮模型 (Wheel Models) 彼此独立](https://docs.unity.cn/cn/2022.2/uploads/Main/WheelsSetup.png)

车轮碰撞体 (Wheel Colliders) 与可见车轮模型 (Wheel Models) 彼此独立

请注意，在播放模式下，WheelCollider 位置的辅助图标图形不会更新：

![使用悬架距离 0.15 的 WheelCollider 辅助图标在运行时的位置](https://docs.unity.cn/cn/2022.2/uploads/Main/WheelColliderGizmo.jpg)

使用悬架距离 0.15 的 WheelCollider 辅助图标在运行时的位置

### Collision geometry

因为赛车可以达到很高的速度，所以正确设置赛道碰撞几何体非常重要。具体而言，[碰撞网格](https://docs.unity.cn/cn/2022.2/Manual/class-MeshCollider.html)不应具有构成可见模型（例如栅栏杆）的微小凹凸痕迹。通常，用于赛道的碰撞网格与可见网格分开制作，使碰撞网格尽可能平滑。此外不应有薄型对象；如果有薄型轨道边界，请在碰撞网格中使其加宽（如果汽车绝不会到达该处，应完全移除另一侧）。

![可见几何体（左侧）比碰撞几何体（右侧）复杂得多](https://docs.unity.cn/cn/2022.2/uploads/Main/WheelGeometries.jpg)

可见几何体（左侧）比碰撞几何体（右侧）复杂得多

### Wheel Friction Curves

下文中显示的_车轮摩擦曲线_可以描述轮胎摩擦。车轮的前进（滚动）方向和侧向方向有单独的曲线。在这两个方向上，首先确定轮胎打滑的程度（基于轮胎橡胶和道路之间的速度差异）。然后，将该打滑值用于计算施加在接触点上的轮胎力。

曲线以轮胎打滑的度量值作为输入，并以力作为输出。曲线由包含两部分的样条图近似模拟。第一部分从 _(0 , 0)_ 到 _(**ExtremumSlip** , **ExtremumValue**)_，目标点处曲线的正切值为零。第二部分从 _(**ExtremumSlip** , **ExtremumValue**)_ 到 _(**AsymptoteSlip** , **AsymptoteValue**)_，目标点处曲线的正切值再次为零：

![车轮摩擦曲线的典型形状](https://docs.unity.cn/cn/2022.2/uploads/Main/WheelFrictionCurve.png)

车轮摩擦曲线的典型形状

根据真实轮胎的特性，在低打滑条件下，轮胎可能会施加很大的力，因为橡胶会通过拉伸来补偿打滑。随后，当打滑变得非常高时，随着轮胎开始滑动或旋转，力会减小。因此，轮胎摩擦曲线的形状与上图相似。

|**_属性：_**|**_功能：_**|
|---|---|
|**Extremum Slip/Value**|曲线的极值点。|
|**Asymptote Slip/Value**|曲线的渐近点。|
|**Stiffness**|**Extremum Value** 和 **Asymptote Value** 的乘数（默认值为 1）。改变摩擦力的刚度。将此值设置为零将完全禁用车轮的所有摩擦力。通常在运行时修改刚度以使用脚本来模拟各种地面材质。|

## 提示

- 可能希望在 [Time](https://docs.unity.cn/cn/2022.2/Manual/class-TimeManager.html) 窗口中降低物理时间步长长度以获得更稳定的汽车物理特性，特别是在高速赛车的情况下。
- 为防止汽车太容易翻转，可以通过脚本稍微降低其[刚体](https://docs.unity.cn/cn/2022.2/Manual/class-Rigidbody.html)质心，并施加取决于汽车速度的“下压”力。
# Mesh Collider component reference

**网格碰撞体 (Mesh Collider)** 采用[网格资源](https://docs.unity.cn/cn/2022.2/Manual/class-Mesh.html)并基于该网格构建其碰撞体。在进行碰撞检测时，Mesh Collider 比使用复杂网格的基元更准确。标记为 **Convex** 的 Mesh Collider 可与其他 Mesh Collider 发生碰撞。

![](https://docs.unity.cn/cn/2022.2/uploads/Main/Inspector-MeshCollider.png)

## 属性

|**_属性_**|   |**_功能_**|
|---|---|---|
|**Convex**|   |选中此复选框将使 Mesh Collider 与其他 Mesh Collider 发生碰撞。**Convex** Mesh Collider 最多 255 个三角形。|
|**Is Trigger**|   |选中此复选框将使 Unity 使用该碰撞体来触发事件，而物理引擎会忽略该碰撞体。|
|**Cooking Options**|   |启用或禁用影响物理引擎对网格处理方式的[网格烹制](https://docs.unity.cn/cn/2022.2/Manual/class-MeshCollider.html#cooking)选项。|
||**None**|禁用下方列出的所有 **Cooking Options**。|
||**Everything**|启用下方列出的所有 **Cooking Options**。|
||**Cook for Faster Simulation**|使物理引擎烹制网格以加快模拟速度。启用此设置后，这会运行一些额外步骤，以保证生成的网格对于运行时性能是最佳的。这会影响物理查询和接触生成的性能。禁用此设置后，物理引擎会使用更快的烹制速度，并尽可能快速生成结果。因此，烹制的 Mesh Collider 可能不是最佳的。|
||**Enable Mesh Cleaning**|使物理引擎清理网格。启用此设置后，烹制过程会尝试消除网格的[退化三角形](https://en.wikipedia.org/wiki/Degeneracy_(mathematics)#Triangle)以及其他几何瑕疵。此过程生成的网格更适合于在碰撞检测中使用，往往可生成更准确的击中点。|
||**Weld Colocated Vertices**|使物理引擎在网格中删除相等的顶点。启用此设置后，物理引擎将合并具有相同位置的顶点。这对于运行时发生的碰撞反馈十分重要。|
||**Use Fast Midphase**|使物理引擎采用可用于您输出平台的最快速的中间阶段加速结构和算法。启用此选项后，物理引擎将使用更快的算法，这个算法不需要任何 R 树 (R-Trees) 即可进行空间访问。如果在某些平台上的运行时遇到中间阶段问题，您仍然可以禁用此选项，从而改用较慢的旧版中间阶段算法。|
|**Material**|   |引用[物理材质](https://docs.unity.cn/cn/2022.2/Manual/class-PhysicMaterial.html)，可确定该碰撞体与其他对象的交互方式。|
|**Mesh**|   |引用需要用于碰撞的网格。|

## 详细信息

Mesh Collider 从附加到游戏对象的[网格](https://docs.unity.cn/cn/2022.2/Manual/class-Mesh.html)构建其碰撞表示，并读取附加的[变换组件](https://docs.unity.cn/cn/2022.2/Manual/class-Transform.html)的属性以正确设置其位置和缩放。这样做的好处是可以使碰撞体的形状与游戏对象可见网格的形状完全相同，从而产生更精确和真实的碰撞。但是，伴随这种精度的不足之处是，与涉及原始碰撞体（例如球体、盒体和胶囊体）的碰撞相比，处理开销会更高，因此最好谨慎使用 Mesh Collider。

碰撞网格中的面为单面。这意味着，游戏对象可从一个方向穿过这些面，但从另一个方向会与这些面碰撞。

如需了解网格碰撞体 (Mesh Collider) 使用的基础算法和数据结构的详细信息，请参阅 [PhysX 文档](https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Manual/Geometry.html)。

## 网格烹制

网格烹制将常规网格更改为可以在物理引擎中使用的网格。烹制会构建用于物理查询的空间搜索结构（如 [Physics.Raycast](https://docs.unity.cn/cn/2022.2/ScriptReference/Physics.Raycast.html)）以及用于接触生成的支持结构。Unity 在碰撞检测中使用网格之前烹制所有这些网格。这可在导入时 (**Import Settings > Model > Generate Colliders**) 或运行时进行。

如果要在运行时生成网格（例如，对于程序化表面），设置 **Cooking Options** 以更快地生成结果并禁用清理过程的其他数据清理步骤将非常有用。缺点是需要生成无退化三角形和非同位顶点，但烹制的运行速度更快。

如果禁用 **Enable Mesh Cleaning** 或 **Weld Colocated Vertices**，则需要确保未使用那些算法在其他情况下可能会过滤的数据。如果禁用了 **Weld Colocated Vertices**，请确保没有任何同位顶点，如果启用了 **Enable Mesh Cleaning**，确保没有面积接近零的小三角形，没有狭长的三角形，也没有面积接近于无限大的大三角形。

**注意**：将 **Cooking Options** 设置为除默认设置之外的任何其他值时，意味着 Mesh Collider 必须使用一个 [isReadable](https://docs.unity.cn/cn/2022.2/ScriptReference/Mesh-isReadable.html) 值为 `true` 的网格。

## 限制

使用 Mesh Collider 时有一些限制：

具有 Rigidbody 组件的游戏对象仅支持启用了 **Convex** 选项的网格碰撞体 (Mesh Collider)：物理引擎只能模拟凸面网格碰撞体。

要使 Mesh Collider 正常工作，网格必须在以下情况下设置为 read/write enabled：

- Mesh Collider 的变换组件具有负缩放（例如 (–1, 1, 1)）并且网格为凸面。
- Mesh Collider 的变换组件是倾斜或截断的（例如，当旋转的变换组件具有缩放的父变换组件时）。
- Mesh Collider 的 **Cooking Options** 标志设置为默认值以外的任何值。

不应修改用于碰撞体的网格几何体，因为每次更改网格时，物理引擎都必须重建内部网格碰撞加速结构。这会导致大量的性能开销。对于需要在运行时发生碰撞和进行更改的网格，通常最好使用诸如胶囊体、球体和盒体之类的原始碰撞体来模拟网格形状。

**优化技巧：**如果 Mesh Collider 仅使用网格，则可以在 **Import Settings** 中禁用 **Normals**，因为物理系统不需要它们。

---

- 在 2018.3 版中更新了 Mesh Collider 限制
    
- 2018–10–12 页面已修订
    
- 在 [2017.3](https://docs.unity.cn/2017.3/Documentation/Manual/30_search.html?q=newin20173) 版中添加了网格的 Cooking Options
    
- 在 2018.1 版中更新了功能
    
- 在 2017.3 版中更新了与 read/write enabled 设置相关的限制
    
- 在 2018.3 版中已弃用 Inflate Convex Mesh，因为新的凸面外壳计算算法 (Quickhull) 更能容忍输入网格中的缺陷。

# Physic Material component reference

The **Physic Material** adjusts friction and bouncing effects of colliding GameObjects.

To create a Physic Material, select **Assets > Create > Physic Material** from the menu bar. Then drag the Physic Material from the Project View onto a **Collider** in the scene.

## 属性

![](https://docs.unity.cn/cn/2022.2/uploads/Main/Inspector-PhysicMaterial.png)

|**_属性：_**|**_功能：_**|
|---|---|
|**Dynamic Friction**|已在移动时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将使对象迅速静止（除非用很大的力或重力推动对象）。|
|**Static Friction**|当对象静止在表面上时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将导致很难让对象移动。|
|**Bounciness**|表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。|
|**Friction Combine**|两个碰撞对象的摩擦力的组合方式。|
|- **Average**|对两个摩擦值求平均值。|
|- **Minimum**|使用两个值中的最小值。|
|- **Maximum**|使用两个值中的最大值。|
|- **Multiply**|两个摩擦值相乘。|
|**Bounce Combine**|两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同|

## 详细信息

摩擦力是防止表面相互滑落的量。尝试堆叠对象时，此值很重要。摩擦力有两种形式：动态和静态。对象静止时使用__静态摩擦力**。静态摩擦力会阻止对象开始移动。如果向对象施加足够大的力，对象将开始移动。随后，__动态摩擦力__将发挥作用。**动态摩擦力__现在将尝试在与另一个对象接触时减慢对象的速度。

当两个对象接触时，根据所选择的模式对它们两者施加相同的弹性和摩擦力效果。当两个接触的碰撞体具有不同的组合模式设置时，存在一种特殊情况。在这种特殊情况下，使用具有最高优先级的函数。优先级顺序如下：__Average__ < **Minimum** < **Multiply** < **Maximum**。例如，如果一种材质设置了 **Average__，但另一种材质设置了** Maximum__，那么要使用的组合函数是 __Maximum__，因为它具有更高的优先级。

请注意，Nvidia PhysX 引擎使用的摩擦力模型针对模拟的性能和稳定性进行了调整，并不一定代表真实物理的高度近似值。具体而言，大于单个点的接触面（例如两个相互叠放在一起的盒子）将计算为具有两个接触点，其摩擦力将是现实世界物理学中的两倍。在这种情况下，可能希望将摩擦系数乘以 0.5 以获得更真实的结果。

同样的逻辑适用于弹性模型。由于各种模拟细节（如位置校正），Nvidia PhysX 无法保证完美的能量守恒效果。因此，比如说，如果受重力影响的对象的弹性值为 1，并与弹性为 1 的地面碰撞，则对象的弹跳高度应该会高于初始位置。

---

- 5.5 版中的更新功能
# 2.共同参数
![[Pasted image 20240906155840.png]]

# 3.常用碰撞器
![[Pasted image 20240906173039.png]]
# 4.异形物体使用多种碰撞器组合
刚体对象的子对象碰撞器信息参与碰撞检测

# 5.不常用碰撞器
![[Pasted image 20240906173321.png]]
![[Pasted image 20240906173610.png]]
