![[Lesson43.cs]]

### 什么是大小端模式
#### **大端模式**
- 数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。
- 这种存储模式类似于将数据视为字符串顺序处理。
- 地址由小向大增加，数据从高位往低位放置。
- 符合人类的阅读习惯。
#### **小端模式**
- 数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。

#### **举例说明**
- 十六进制数据 `0x11223344`，44 是最低字节，11 是最高字节。
- 大端模式存储：
    ```
    11    22    33    44
    0     1     2     3
    ```
    
- 小端模式存储：
    ```
    44    33    22    11
    0     1     2     3
    ```

### 为什么有大小端模式
- 大小端模式是计算机硬件的两种存储数据的方式，也称为大小端字节序。
- 计算机内部处理时，不知道什么是高位字节，什么是低位字节，只按顺序读取字节。
- 计算机电路先处理低位字节，效率较高，因此采用小端模式。
- 我们人类的读写习惯是大端字节序，但在计算机内部处理时，采用小端字节序。
- 在网络传输和文件存储等场合，一般采用大端模式。

### 大小端模式对于我们的影响
- **只有读取的时候，才必须区分大小端字节序，其它情况都不用考虑。**
- 在网络传输中，前后端语言、设备可能导致大小端不统一，需要进行大小端转换。
- 通常，C# 和 Java/Erlang/AS3 通讯需要进行大小端转换，而 C# 与 C++ 通信不需要特殊处理。

### 大小端转换
[BitConverter 类 (System) | Microsoft Learn](h
```embed
title: "BitConverter 类 (System)"
image: "https://learn.microsoft.com/en-us/media/open-graph-image.png"
description: "将基数据类型转换为字节数组，将字节数组转换为基数据类型。 "
url: "https://learn.microsoft.com/zh-cn/dotnet/api/system.bitconverter?view=net-8.0"
favicon: ""
aspectRatio: "52.5"
```

#### BitConverter.IsLittleEndian 判断是大小端哪种模式
```cs
print("是否是小端模式:" + BitConverter.IsLittleEndian);
```
#### IPAddress.HostToNetworkOrder 转为大端模式
```cs
// 1. 本机字节序转网络字节序 HostToNetworkOrder 方法
//转换为网络字节序 相当于就是转为大端模式
int i = 99;
byte[] bytes = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(i));
```
#### IPAddress.NetworkToHostOrder 转为小端模式
```cs
// 2. 网络字节序转本机字节序 NetworkToHostOrder 方法
//网络字节序转换为本机字节序 相当于就是转为小端模式
int receI = BitConverter.ToInt32(bytes, 0);
receI = IPAddress.NetworkToHostOrder(receI);
```
#### Array.Reverse 倒序数组转换
```cs
//数组中的倒序API
//如果后端需要用到大端模式 那么我们进行判断
//如果当前是小端模式 就进行一次 大小端转换
if (BitConverter.IsLittleEndian)
    Array.Reverse(bytes);
```

### 总结
- 大小端模式会根据主机硬件环境、语言而有所区别。
- 在前后端语言不同且运行在不同主机上时，需要对大小端字节序定下统一的规则。
- 一般让前端迎合后端，以减轻后端的负担，特别是在网络游戏中。
- 注意在开发中发现消息不一致时，考虑大小端模式带来的影响。
- 使用 Protobuf 可以简化大小端转换的问题。

