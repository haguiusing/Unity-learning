![[Lesson3 4.cs]]

### 非字符串类型转字节数组
- 关键类：BitConverter
- 所在命名空间：System
- 主要作用：除字符串的其它常用类型和字节数组相互转换
```cs
//把int型的1转换成字节数组
byte[] byteArray1 = BitConverter.GetBytes(1);
```

### 字符串类型转字节数组
- 关键类：Encoding
- 所在命名空间：System.Text
- 主要作用：将字符串类型和字节数组相互转换，并且决定转换时使用的字符编码类型，网络通信时建议大家使用UTF-8类型
```cs
//转换字符串人间自有韬哥在
byte[] byteArray2 = Encoding.UTF8.GetBytes("人间自有韬哥在");
```

### 如何将一个类对象转换为二进制
- 注意：网络通信中我们不能直接使用数据持久化2进制知识点中的
    - BinaryFormatter 2进制格式化类
    - 因为客户端和服务器使用的语言可能不一样，BinaryFormatter是C#的序列化规则，和其它语言之间的兼容性不好
    - 如果使用它，那么其它语言开发的服务器无法对其进行反序列化
    - 我们需要自己来处理将类对象数据序列化为字节数组

#### 声明测试类对象
```cs
public class PlayerInfo
{
    public int lev;
    public string name;
    public short atk;
    public bool sex;
}
```

#### 将类对象转换成字节数组
```cs
//单纯的转换一个变量为字节数组非常的简单
//但是我们如何将一个类对象携带的所有信息放入到一个字节数组中呢
//我们需要做以下几步

//1.明确 装载playerInfo 所有数据信息 的字节数组 的容量（注意：在确定字符串字节长度时要考虑解析时如何处理）
PlayerInfo playerInfo = new PlayerInfo();
playerInfo.lev = 10;
playerInfo.name = "韬老狮";
playerInfo.atk = 88;
playerInfo.sex = false;

//得到的 这个Info数据 如果转换成 字节数组 那么字节数组容器需要的容量
int indexNum = sizeof(int) + //lev int类型  4
               sizeof(int) + //代表 name字符串转换成字节数组后 name数组的长度 4
               Encoding.UTF8.GetBytes(playerInfo.name).Length + //name字符串具体字节数组的长度
               sizeof(short) + //atk short类型 2
               sizeof(bool); //sex bool类型 1

//2.申明一个 装载playerInfo 所有数据信息 的字节数组容器
byte[] playerBytes = new byte[indexNum];

//3.将对象中的所有信息转为字节数组并放入 装载playerInfo 所有数据信息 的字节数组容器 中（可以利用数组中的CopeTo方法转存字节数组）
//CopyTo方法的第二个参数代表 从容器的第几个位置开始存储
int index = 0;//从 playerBytes数组中的第几个位置去存储数据

//等级 把等级转成字节数组 拷贝到  装载playerInfo 所有数据信息 的字节数组容器
BitConverter.GetBytes(playerInfo.lev).CopyTo(playerBytes, index);
index += sizeof(int);//索引加上对应字节

//姓名 姓名长度是不固定的 所以要先存姓名长度 用int来存
byte[] strBytes = Encoding.UTF8.GetBytes(playerInfo.name);
int num = strBytes.Length;//姓名占多少字节
//存储的是姓名转换成字节数组后 字节数组的长度
BitConverter.GetBytes(num).CopyTo(playerBytes, index);
index += sizeof(int);//索引加上对应字节
//存储字符串的字节数组 真正的存入姓名
strBytes.CopyTo(playerBytes, index);
index += num;//存入姓名后加上索引

//攻击力 把攻击力转成字节数组 拷贝到  装载playerInfo 所有数据信息 的字节数组容器
BitConverter.GetBytes(playerInfo.atk).CopyTo(playerBytes, index);
index += sizeof(short);//索引加上对应字节

//性别 把性别转成字节数组 拷贝到  装载playerInfo 所有数据信息 的字节数组容器
BitConverter.GetBytes(playerInfo.sex).CopyTo(playerBytes, index);
index += sizeof(bool);//索引加上对应字节
```

#### 可以在类对象封装转换方法
```cs
public byte[] GetBytes()
{
    int indexNum = sizeof(int) + //lev int类型  4
                   sizeof(int) + //代表 name字符串转换成字节数组后 数组的长度 4
                   Encoding.UTF8.GetBytes(name).Length + //字符串具体字节数组的长度
                   sizeof(short) + //atk short类型 2
                   sizeof(bool); //sex bool类型 1

    byte[] playerBytes = new byte[indexNum];
    int index = 0;//从 playerBytes数组中的第几个位置去存储数据

    //等级
    BitConverter.GetBytes(lev).CopyTo(playerBytes, index);
    index += sizeof(int);

    //姓名
    byte[] strBytes = Encoding.UTF8.GetBytes(name);
    int num = strBytes.Length;
    //存储的是姓名转换成字节数组后 字节数组的长度
    BitConverter.GetBytes(num).CopyTo(playerBytes, index);
    index += sizeof(int);
    //存储字符串的字节数组
    strBytes.CopyTo(playerBytes, index);
    index += num;

    //攻击力
    BitConverter.GetBytes(atk).CopyTo(playerBytes, index);
    index += sizeof(short);
    //性别
    BitConverter.GetBytes(sex).CopyTo(playerBytes, index);
    index += sizeof(bool);

    return playerBytes;
}
```

### 总结
- 我们对类对象的2进制序列化主要用到的知识点是
    - BitConverter转换非字符串的类型的变量为字节数组
    - Encoding.UTF8转换字符串类型的变量为字节数组（注意：为了考虑反序列化，我们在转存2进制，序列化字符串之前，先序列化字符串字节数组的长度）
- 转换流程是
    - 明确字节数组的容量
    - 申明一个装载信息的字节数组容器
    - 将对象中的所有信息转为字节数组并放入该容器当中（利用数组中的CopeTo方法转存字节数组）

将数据从一个字节数组复制到另一个字节数组时，除了使用 `CopyTo` 方法外，还有其他几种方法可以实现相同的功能。以下是一些常见的替代方法：
### 1. 使用 `Buffer.BlockCopy`
`Buffer.BlockCopy` 是一个高效的方法，用于在字节数组之间复制数据块。它比 `CopyTo` 更快，尤其是在处理大块数据时。
```csharp
public byte[] GetBytes()
{
    int indexNum = sizeof(int) + // lev int类型 4
                   sizeof(int) + // 代表 name字符串转换成字节数组后 数组的长度 4
                   Encoding.UTF8.GetBytes(name).Length + // 字符串具体字节数组的长度
                   sizeof(short) + // atk short类型 2
                   sizeof(bool); // sex bool类型 1

    byte[] playerBytes = new byte[indexNum];
    int index = 0; // 从 playerBytes 数组中的第几个位置去存储数据

    // 等级
    byte[] levBytes = BitConverter.GetBytes(lev);
    Buffer.BlockCopy(levBytes, 0, playerBytes, index, sizeof(int));
    index += sizeof(int);

    // 姓名
    byte[] strBytes = Encoding.UTF8.GetBytes(name);
    int num = strBytes.Length;
    // 存储的是姓名转换成字节数组后 字节数组的长度
    byte[] numBytes = BitConverter.GetBytes(num);
    Buffer.BlockCopy(numBytes, 0, playerBytes, index, sizeof(int));
    index += sizeof(int);
    // 存储字符串的字节数组
    Buffer.BlockCopy(strBytes, 0, playerBytes, index, num);
    index += num;

    // 攻击力
    byte[] atkBytes = BitConverter.GetBytes(atk);
    Buffer.BlockCopy(atkBytes, 0, playerBytes, index, sizeof(short));
    index += sizeof(short);

    // 性别
    byte[] sexBytes = BitConverter.GetBytes(sex);
    Buffer.BlockCopy(sexBytes, 0, playerBytes, index, sizeof(bool));
    index += sizeof(bool);

    return playerBytes;
}
```

### 2. 使用 `Array.Copy`
`Array.Copy` 是一个通用的方法，用于在数组之间复制数据。它比 `CopyTo` 更灵活，可以指定源数组和目标数组的起始索引。
```csharp
public byte[] GetBytes()
{
    int indexNum = sizeof(int) + // lev int类型 4
                   sizeof(int) + // 代表 name字符串转换成字节数组后 数组的长度 4
                   Encoding.UTF8.GetBytes(name).Length + // 字符串具体字节数组的长度
                   sizeof(short) + // atk short类型 2
                   sizeof(bool); // sex bool类型 1

    byte[] playerBytes = new byte[indexNum];
    int index = 0; // 从 playerBytes 数组中的第几个位置去存储数据

    // 等级
    byte[] levBytes = BitConverter.GetBytes(lev);
    Array.Copy(levBytes, 0, playerBytes, index, sizeof(int));
    index += sizeof(int);

    // 姓名
    byte[] strBytes = Encoding.UTF8.GetBytes(name);
    int num = strBytes.Length;
    // 存储的是姓名转换成字节数组后 字节数组的长度
    byte[] numBytes = BitConverter.GetBytes(num);
    Array.Copy(numBytes, 0, playerBytes, index, sizeof(int));
    index += sizeof(int);
    // 存储字符串的字节数组
    Array.Copy(strBytes, 0, playerBytes, index, num);
    index += num;

    // 攻击力
    byte[] atkBytes = BitConverter.GetBytes(atk);
    Array.Copy(atkBytes, 0, playerBytes, index, sizeof(short));
    index += sizeof(short);

    // 性别
    byte[] sexBytes = BitConverter.GetBytes(sex);
    Array.Copy(sexBytes, 0, playerBytes, index, sizeof(bool));
    index += sizeof(bool);

    return playerBytes;
}
```

### 3. 使用 `Span<T>` 和 `Memory<T>`
单一数据类型
```csharp
public byte[] GetBytes()
{
    int indexNum = sizeof(int) + // lev int类型 4
                   sizeof(int) + // 代表 name字符串转换成字节数组后 数组的长度 4
                   Encoding.UTF8.GetBytes(name).Length + // 字符串具体字节数组的长度
                   sizeof(short) + // atk short类型 2
                   sizeof(bool); // sex bool类型 1

    byte[] playerBytes = new byte[indexNum];
    int index = 0; // 从 playerBytes 数组中的第几个位置去存储数据

    // 等级
    Span<byte> levBytes = BitConverter.GetBytes(lev);
    levBytes.CopyTo(playerBytes.AsSpan(index, sizeof(int)));
    index += sizeof(int);

    // 姓名
    byte[] strBytes = Encoding.UTF8.GetBytes(name);
    int num = strBytes.Length;
    // 存储的是姓名转换成字节数组后 字节数组的长度
    Span<byte> numBytes = BitConverter.GetBytes(num);
    numBytes.CopyTo(playerBytes.AsSpan(index, sizeof(int)));
    index += sizeof(int);
    // 存储字符串的字节数组
    strBytes.AsSpan().CopyTo(playerBytes.AsSpan(index, num));
    index += num;

    // 攻击力
    Span<byte> atkBytes = BitConverter.GetBytes(atk);
    atkBytes.CopyTo(playerBytes.AsSpan(index, sizeof(short)));
    index += sizeof(short);

    // 性别
    Span<byte> sexBytes = BitConverter.GetBytes(sex);
    sexBytes.CopyTo(playerBytes.AsSpan(index, sizeof(bool)));
    index += sizeof(bool);

    return playerBytes;
}
```

### 4. 使用 `Memory<T>.CopyTo`
`Memory<T>.CopyTo` 是 `Memory<T>` 类的一个方法，用于将一个内存块复制到另一个内存块中。它比 `CopyTo` 更灵活，可以指定源和目标的起始位置。
```csharp
public byte[] GetBytes()
{
    int indexNum = sizeof(int) + // lev int类型 4
                   sizeof(int) + // 代表 name字符串转换成字节数组后 数组的长度 4
                   Encoding.UTF8.GetBytes(name).Length + // 字符串具体字节数组的长度
                   sizeof(short) + // atk short类型 2
                   sizeof(bool); // sex bool类型 1

    byte[] playerBytes = new byte[indexNum];
    int index = 0; // 从 playerBytes 数组中的第几个位置去存储数据

    // 等级
    Memory<byte> levBytes = BitConverter.GetBytes(lev);
    levBytes.CopyTo(playerBytes.AsMemory(index, sizeof(int)));
    index += sizeof(int);

    // 姓名
    byte[] strBytes = Encoding.UTF8.GetBytes(name);
    int num = strBytes.Length;
    // 存储的是姓名转换成字节数组后 字节数组的长度
    Memory<byte> numBytes = BitConverter.GetBytes(num);
    numBytes.CopyTo(playerBytes.AsMemory(index, sizeof(int)));
    index += sizeof(int);
    // 存储字符串的字节数组
    new Memory<byte>(strBytes).CopyTo(playerBytes.AsMemory(index, num));
    index += num;

    // 攻击力
    Memory<byte> atkBytes = BitConverter.GetBytes(atk);
    atkBytes.CopyTo(playerBytes.AsMemory(index, sizeof(short)));
    index += sizeof(short);

    // 性别
    Memory<byte> sexBytes = BitConverter.GetBytes(sex);
    sexBytes.CopyTo(playerBytes.AsMemory(index, sizeof(bool)));
    index += sizeof(bool);

    return playerBytes;
}
```