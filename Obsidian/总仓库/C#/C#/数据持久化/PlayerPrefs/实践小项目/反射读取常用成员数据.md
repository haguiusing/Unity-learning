![[PlayerPrefs数据管理类#^cc96f5]]
### 对应这存储的key，添加读取数据的逻辑
```cs
/// <summary>
/// 读取数据
/// </summary>
/// <param name="type">想要读取数据的 数据类型Type</param>
/// <param name="keyName">数据对象的唯一key 自己控制</param>
/// <returns></returns>
public object LoadData(Type type, string keyName)
{
    Log("读取自定义类型" + keyName);
    //不用object对象传入 而使用 Type传入
    //主要目的是节约一行代码（在外部）
    //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入
    //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来
    //达到了 让你在外部 少写一行代码的作用

    //根据你传入的类型 和 keyName
    //依据你存储数据时  key的拼接规则 来进行数据的获取赋值 返回出去

    //根据传入的Type 创建一个对象 用于存储数据 要确保传进来的类型又无参构造
    object data = Activator.CreateInstance(type);

    //接下来的目的就是要往 这个new出来的对象中存储数据 填充数据

    //得到这个类所有字段的字段数组
    FieldInfo[] infos = type.GetFields();

    //用于拼接key的字符串
    string loadKeyName = "";

    //用于存储 单个字段信息的 对象 方便等一下遍历使用
    FieldInfo info;

    //遍历这个类的字段数组
    for (int i = 0; i < infos.Length; i++)
    {
        //获得单条字段
        info = infos[i];

        //key的拼接规则 一定是和存储时一模一样 这样才能找到对应数据
        loadKeyName = keyName + "_" + type.Name +
            "_" + info.FieldType.Name + "_" + info.Name;

        //有key 就可以结合 PlayerPrefs来读取数据
        //SetValue方法 赋值数据给对象 填充数据到data对象中 
        info.SetValue(data, LoadValue(info.FieldType, loadKeyName));
    }

    //返回填充完的data对象
    return data;
}
```

#### `SetValue` 方法的签名
```csharp
public void SetValue(object obj, object value);
```

- **`obj`**：目标对象，即要设置字段值的对象。
- **`value`**：要赋给字段的值。
##### 使用规则
1. **目标对象 (`obj`)**
    - `obj` 是包含要设置字段的对象实例。
    - 如果字段是静态字段，则 `obj` 可以是 `null`。
    - 如果字段是非静态字段，则 `obj` 必须是字段所属类的实例。
        
2. **字段值 (`value`)**
    - `value` 是要赋给字段的值。
    - `value` 的类型必须与字段的类型兼容。如果类型不匹配，可能会抛出异常（如 `ArgumentException` 或 `InvalidCastException`）。
        
3. **字段类型**
    - `FieldInfo` 对象表示的字段类型必须与 `value` 的类型一致。
    - 如果字段是基本类型（如 `int`、`float`、`string` 等），`value` 必须是对应的基本类型。
    - 如果字段是复杂类型（如自定义类、集合等），`value` 必须是该复杂类型的实例。
### 对应这存储的key，添加读取单个具体数据的逻辑
```cs
/// <summary>
/// 得到单个数据的方法
/// </summary>
/// <param name="fieldType">字段类型 用于判断 用哪个api来读取</param>
/// <param name="keyName">用于获取具体数据</param>
/// <returns></returns>
private object LoadValue(Type fieldType, string keyName)
{
    //根据 字段类型 来判断 用哪个API来读取
    if (fieldType == typeof(int))
    {
        return PlayerPrefs.GetInt(keyName, 0);
    }
    else if (fieldType == typeof(float))
    {
        return PlayerPrefs.GetFloat(keyName, 0);
    }
    else if (fieldType == typeof(string))
    {
        return PlayerPrefs.GetString(keyName, "");
    }
    else if (fieldType == typeof(bool))
    {
        //根据自定义存储bool的规则 来进行值的获取
        return PlayerPrefs.GetInt(keyName, 0) == 1 ? true : false;
    }

    return null;
}
```

### 在测试类调用读取逻辑测试
```cs
//读取数据 传入读取数据的类和唯一key
PlayerInfo p1 = PlayerPrefsDataMgr.Instance.LoadData(typeof(PlayerInfo), "Player1") as PlayerInfo;
```

### 注意事项
1. **类型匹配**
    - `SetValue` 的 `value` 参数类型必须与字段类型一致。如果类型不匹配，可能会抛出异常。
    - 在你的代码中，`LoadValue` 方法会根据字段类型调用不同的 `PlayerPrefs` 方法，确保返回的值类型与字段类型一致。
        
2. **字段访问权限**
    - 如果字段是私有的，需要确保 `FieldInfo` 对象有足够的权限访问字段。可以通过设置 `BindingFlags` 来获取私有字段：
```csharp
    FieldInfo[] infos = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
```

### `BindingFlags` 的作用
`BindingFlags` 主要用于以下几种反射方法：
- **`Type.GetFields`**：获取类的字段。
- **`Type.GetProperties`**：获取类的属性。
- **`Type.GetMethods`**：获取类的方法。
- **`Type.GetConstructors`**：获取类的构造函数。
- **`Type.InvokeMember`**：调用类的成员（如方法、属性、字段等）。

通过指定不同的 `BindingFlags`，可以精确地控制反射操作的行为，例如是否包括私有成员、是否搜索继承的成员等。

### `BindingFlags` 的常见组合
以下是一些常用的 `BindingFlags` 组合及其含义：
1. **`BindingFlags.Public | BindingFlags.Instance`**
    - 获取类的公共实例成员（字段、属性、方法等）。
    - 示例：
```csharp
FieldInfo[] fields = typeof(MyClass).GetFields(BindingFlags.Public | BindingFlags.Instance);
```
    
2. **`BindingFlags.Public | BindingFlags.Static`**
    - 获取类的公共静态成员。
    - 示例：
```csharp
FieldInfo[] fields = typeof(MyClass).GetFields(BindingFlags.Public | BindingFlags.Static);
```        ```
        
3. **`BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance`**
    - 获取类的所有实例成员（包括公共和私有）。
    - 示例：
```csharp
FieldInfo[] fields = typeof(MyClass).GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
```
        
4. **`BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static`**
    - 获取类的所有静态成员（包括公共和私有）。
    - 示例：
```csharp
FieldInfo[] fields = typeof(MyClass).GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
```
        
5. **`BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static`**
    - 获取类的所有成员（包括公共和私有，实例和静态）。
    - 示例：
```csharp
FieldInfo[] fields = typeof(MyClass).GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
```
        
6. **`BindingFlags.Instance | BindingFlags.NonPublic`**
    - 获取类的私有实例成员。
    - 示例：
```csharp
FieldInfo[] fields = typeof(MyClass).GetFields(BindingFlags.Instance | BindingFlags.NonPublic);
```

### `BindingFlags` 的具体标志
以下是 `BindingFlags` 枚举中各个标志的含义：
- **`Default`**：默认值，不指定任何特殊绑定。
- **`IgnoreCase`**：忽略大小写。
- **`DeclaredOnly`**：仅搜索声明的成员，不包括继承的成员。
- **`Instance`**：搜索实例成员。
- **`Static`**：搜索静态成员。
- **`Public`**：搜索公共成员。
- **`NonPublic`**：搜索非公共成员（私有、受保护等）。
- **`FlattenHierarchy`**：在搜索时忽略继承层次结构。
- **`InvokeMethod`**：用于调用方法。
- **`CreateInstance`**：用于创建实例。
- **`GetField`**：用于获取字段。
- **`SetField`**：用于设置字段。
- **`GetProperty`**：用于获取属性。
- **`SetProperty`**：用于设置属性。
- **`ExactBinding`**：要求精确匹配。
- **`SuppressChangeType`**：抑制类型转换。
- **`OptionalParamBinding`**：允许使用可选参数。
- **`IgnoreReturn`**：忽略返回值。
- **`DoNotWrapExceptions`**：不包装异常。

### 示例：使用 `BindingFlags` 获取私有字段
假设有一个类 `MyClass`，其中包含一个私有字段 `private int secret`：
```csharp
public class MyClass
{
    private int secret = 42;
}
```

可以通过以下方式使用 `BindingFlags` 获取并访问该私有字段：
```csharp
MyClass obj = new MyClass();
FieldInfo field = typeof(MyClass).GetField("secret", BindingFlags.NonPublic | BindingFlags.Instance);
if (field != null)
{
    int value = (int)field.GetValue(obj);
    Console.WriteLine(value); // 输出 42
}
```