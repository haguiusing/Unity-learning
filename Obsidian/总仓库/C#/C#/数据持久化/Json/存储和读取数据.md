![[JsonMgr 3.cs]]

### 创建Json类型方案枚举，可以让外部选择用哪个方案
```cs
/// <summary>
/// 序列化和反序列化Json时 使用的是哪种方案
/// </summary>
public enum JsonType
{
    JsonUtlity,
    LitJson,
}
```

### 创建存储Json数据方法。
外部传入对象和文件名，可以选择Json方案。
确定存储路径，判断Json类型方案选择不同的序列化方法得到对应Json字符串，写入文件到对应路径中
```cs
//存储Json数据 序列化
public void SaveData(object data, string fileName, JsonType type = JsonType.LitJson)
{
    //确定存储路径
    string path = Application.persistentDataPath + "/" + fileName + ".json";
    //序列化 得到Json字符串
    string jsonStr = "";
    switch (type)
    {
        case JsonType.JsonUtlity:
            jsonStr = JsonUtility.ToJson(data);
            break;
        case JsonType.LitJson:
            jsonStr = JsonMapper.ToJson(data);
            break;
    }
    //把序列化的Json字符串 存储到指定路径的文件中
    File.WriteAllText(path, jsonStr);
}
```

### 创建读取Json数据的方法。
外部传入文件名，可以选择Json方案。
确定从哪个路径读取文件。
首先判断默认数据文件夹（Application.streamingAssetsPath）中是否有我们想要的文件，如果有就从中获取。如果没有，就判断读写文件夹（Application.persistentDataPath）中是否有，如果有就从中获取。如果都没有，就返回一个新创建的对象。注意这个给这个方法添加泛型约束有默认无参构造函数。
读取文件内容，把它存储在一个字符串变量jsonStr中。根据Json类型的参数，选择使用哪种库来把jsonStr转换成一个指定类型的对象data。返回data对象。
```cs
//读取指定文件中的 Json数据 反序列化
public T LoadData<T>(string fileName, JsonType type = JsonType.LitJson) where T : new()
{
    //确定从哪个路径读取
    //首先先判断 默认数据文件夹中是否有我们想要的数据 如果有 就从中获取
    string path = Application.streamingAssetsPath + "/" + fileName + ".json";
    //先判断 是否存在这个文件
    //如果不存在默认文件 就从 读写文件夹中去寻找
    if(!File.Exists(path))
        path = Application.persistentDataPath + "/" + fileName + ".json";
    //如果读写文件夹中都还没有 那就返回一个默认对象
    if (!File.Exists(path))
        return new T();

    //进行反序列化
    string jsonStr = File.ReadAllText(path);
    //数据对象
    T data = default(T);
    switch (type)
    {
        case JsonType.JsonUtlity:
            data = JsonUtility.FromJson<T>(jsonStr);
            break;
        case JsonType.LitJson:
            data = JsonMapper.ToObject<T>(jsonStr);
            break;
    }

    //把对象返回出去
    return data;
}
```

