**1.了解帧的概念**
游戏的本质就是一个死循环，每一次循环处理游戏逻辑，就会更新一次画面，之所以能看到画面在动是因为切换画面的速度达到一定时人眼就认为画面是流畅的，一帧就是执行一次循环。

fps(Frame Per Second):即每秒钟帧数，一般我们说的60帧30帧意思是1秒更新60次，30次画面。1s=1000ms,60帧：1帧为16.66ms,30帧：一帧为33.33ms,人眼舒适放松时可视帧数是每秒24帧。

游戏卡顿的原因：跑1帧游戏逻辑中的计算量过大，或者CPU不给力，不能在一帧的时间内处理完所有游戏逻辑。

Unity底层已经帮助我们做好了死循环，我们需要学习Unity的生命周期函数，利用它做好的规则来执行我们的游戏逻辑就可以了。

**2.了解生命周期函数的概念**
所有继承MonoBehavior的脚本，最终都会挂载到GameObject游戏对象上，生命周期函数就是该脚本对象依附GameObject对象从出生到消亡整个生命周期中会通过反射自动调用的一些特殊函数。

Unity帮助我们记录了一个GameObject对象依附了哪些脚本。会自动的得到这些对象，通过反射去执行一些固定名字的函数。

**3.生命周期函数（默认私有）**
注意：生命周期函数的访问修饰符一般为private和protected.

因为不需要在外部自己调用生命周期函数，都是Unity自己帮助我们调用的。

Awake:
出生时调用，类似构造函数，一个对象只会调用一次。
```
//类似构造函数的存在，我们可以在一个类对象刚创建时进行一些初始化操作

void Awake()
{
  //在Unity中打印信息的两种方式：
  //1.在没有继承MonoBehavior类的时候
  Debug.Log("NicolePotter");
  //一种静态方法
  //Debug.LogError("出错了");
  //Debug.LogWarning("警告");
  
  //继承了MonoBehavior有一个线程的方法可以使用
  print("NicolePotter");
}
```

OnEnable:
依附的GameObject对象每次激活时调用。（只有失活激活使用，与循环无关）
```
//对于我们来说，想要当一个对象被激活时，进行一些逻辑处理，就可以写在这个函数
void OnEnable()
{
  print("OnEnable");
}
```

Start:
(Awake执行时间早于Start)
从自己被创建出来后，第一次帧更新之前调用一个对象只会调用一次。
```
//主要作用还是用于初始化信息的，但是它相对于Awake来说，要晚一点
//因为它是在对象进行第一次帧更新前才会执行的
void Start()
{
  print("Start");
}
```

FixedUpdate:
物理帧更新，固定间隔时间执行，间隔时间可以控制。
用于物理帧更新的函数使用次数不多。
```
//它主要是用于进行物理更新
//它是每一帧执行的，但是这里的帧和游戏帧有点不同
//它的时间间隔是可以在project setting中的Time里去设置的
void FixedUpdate()
{
  print("FixedUpdate");
}
```

Update:
逻辑帧更新：每帧执行。
用于游戏逻辑更新的函数，常用
```
//主要用于处理游戏核心逻辑更新的函数
void Update()
{
  print("Update");
  //默认以最快的速度跑
}
```

LateUpdate:
每帧执行，于Update之后执行。
```
//一般这个更新是用来处理摄像机位置更新相关内容的
//Update和LateUpdate之间unity进行了一些处理，处理我们动画相关的更新
void LateUpdate()
{
 print("LateUpdate");
}
```
它与Update的速度是相同的，只是一前一后执行而已。

OnDisable:
依附的GameObject对象每次失活时调用。（只有失活激活使用，与循环无关）
```
//如果我们希望在一个对象失活时做一些处理，就可以在该函数中写逻辑
void OnDisable()
{
  print("OnDisable");
}
```

OnDestroy:
对象销毁时调用，依附的GameObject对象被删除时调用，与OnDisable不同的是，它只会调用一次。

**4.生命周期函数支持继承多态**
继承了父类所有生命周期函数。如果你不需要在这些生命周期函数中写逻辑，就不需要这些生命周期函数。

![[monobehaviour_flowchart.svg]]
