## 代理模式
代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。

模式结构：
- Subject: 抽象主题角色
- Proxy: 代理主题角色
- RealSubject: 真实主题角色
- Client：客户类
![[Pasted image 20250424205224.jpg]]

- **`ISubject` 抽象主题角色**：定义了显示图像的接口。
- **`RealSubject` 真实主题角色**：实现了 `ISubject` 接口，负责加载和显示图像。它模拟了从磁盘加载图像文件的过程。
- **`Proxy` 代理主题角色**：实现了 `ISubject` 接口，内部维护一个指向 `RealSubject` 的引用。第一次调用 `Display` 方法时，它会创建 `RealSubject` 对象并加载图像；之后再次调用 `Display` 方法时，直接使用已加载的图像，避免重复加载。
- **`Client` 客户类**：演示了如何使用代理来获取和显示图像。
``` cs
using System;

namespace ProxyPattern
{
    // 抽象主题角色
    public interface ISubject
    {
        void Display();
    }

    // 真实主题角色
    public class RealSubject : ISubject
    {
        private string FileName;

        public RealSubject(string fileName)
        {
            FileName = fileName;
            LoadFromDisk(fileName);
        }

        public void Display()
        {
            Console.WriteLine("Displaying " + FileName);
        }

        private void LoadFromDisk(string fileName)
        {
            Console.WriteLine("Loading " + fileName);
        }
    }

    // 代理主题角色
    public class Proxy : ISubject
    {
        private RealSubject realSubject;
        private string FileName;

        public Proxy(string fileName)
        {
            FileName = fileName;
        }

        public void Display()
        {
            if (realSubject == null)
            {
                realSubject = new RealSubject(FileName);
            }
            realSubject.Display();
        }
    }

    // 客户类
    public class Client
    {
        public static void Main(string[] args)
        {
            ISubject image = new Proxy("test_10mb.jpg");

            // 图像将从磁盘加载
            image.Display();
            Console.WriteLine("");

            // 图像不需要从磁盘加载
            image.Display();
        }
    }
}
```

### 运行结果
``` cs
Loading test_10mb.jpg
Displaying test_10mb.jpg

Displaying test_10mb.jpg
```

![[Pasted image 20250424205228.jpg]]

## 与其他模式的关系
- [适配器模式](https://refactoringguru.cn/design-patterns/adapter)能为被封装对象提供不同的接口， [代理模式](https://refactoringguru.cn/design-patterns/proxy)能为对象提供相同的接口， [装饰模式](https://refactoringguru.cn/design-patterns/decorator)则能为对象提供加强的接口。
    
- [外观模式](https://refactoringguru.cn/design-patterns/facade)与[代理](https://refactoringguru.cn/design-patterns/proxy)的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 _代理_与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与_外观_不同。
    
- [装饰](https://refactoringguru.cn/design-patterns/decorator)和[代理](https://refactoringguru.cn/design-patterns/proxy)有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于_代理_通常自行管理其服务对象的生命周期， 而_装饰_的生成则总是由客户端进行控制。