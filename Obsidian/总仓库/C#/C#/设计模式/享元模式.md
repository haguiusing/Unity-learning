 ## 享元模式
享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。
享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。
享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 _Circle_ 对象。

模式结构：
- Flyweight: 抽象享元类
- ConcreteFlyweight: 具体享元类
- UnsharedConcreteFlyweight: 非共享具体享元类
- FlyweightFactory: 享元工厂类
- Client：客户类

**享元模式包含以下几个核心角色：**
- **享元工厂（Flyweight Factory）:**
    - 负责创建和管理享元对象，通常包含一个池（缓存）用于存储和复用已经创建的享元对象。
- **具体享元（Concrete Flyweight）:**
    - 实现了抽象享元接口，包含了内部状态和外部状态。内部状态是可以被共享的，而外部状态则由客户端传递。
- **抽象享元（Flyweight）:**
    - 定义了具体享元和非共享享元的接口，通常包含了设置外部状态的方法。
- **客户端（Client）:**
    - 使用享元工厂获取享元对象，并通过设置外部状态来操作享元对象。客户端通常不需要关心享元对象的具体实现。

![[Pasted image 20250424203032.jpg]]
- **`IFlyweight` 抽象享元类接口**：定义了绘图功能的接口。
- **`ConcreteFlyweightCircle` 具体享元类**：实现了 `IFlyweight` 接口，表示一个具体的圆，其颜色是内部状态（共享的），而位置和半径是外部状态（在调用时传入）。
- **`UnsharedConcreteFlyweightCircle` 非共享具体享元类（可选）**：如果需要某些对象不共享，可以使用此类。在这个示例中没有使用，仅作为示例展示。
- **`FlyweightFactory` 享元工厂类**：负责创建和管理享元对象，确保相同颜色的圆只创建一次，从而节省内存。
- **`Client` 客户类**：演示了如何使用享元工厂来获取享元对象，并调用其绘图方法。

### 步骤 1：创建抽象享元类接口
```csharp
// 抽象享元类接口
public interface IFlyweight
{
    void Draw(int x, int y, int radius);
}
```

### 步骤 2：创建具体享元类
```csharp
// 具体享元类
public class ConcreteFlyweightCircle : IFlyweight
{
    private string color;

    public ConcreteFlyweightCircle(string color)
    {
        this.color = color;
    }

    public void Draw(int x, int y, int radius)
    {
        Console.WriteLine($"Circle: Draw() [Color : {color}, x : {x}, y : {y}, radius : {radius}");
    }
}
```

### 步骤 3：创建非共享具体享元类（可选）
```csharp
// 非共享具体享元类
public class UnsharedConcreteFlyweightCircle : IFlyweight
{
    private string color;
    private int x;
    private int y;
    private int radius;

    public UnsharedConcreteFlyweightCircle(string color)
    {
        this.color = color;
    }

    public void Draw(int x, int y, int radius)
    {
        this.x = x;
        this.y = y;
        this.radius = radius;
        Console.WriteLine($"Unshared Circle: Draw() [Color : {color}, x : {x}, y : {y}, radius : {radius}");
    }
}
```

### 步骤 4：创建享元工厂类
```csharp
using System.Collections.Generic;

// 享元工厂类
public class FlyweightFactory
{
    private static readonly Dictionary<string, IFlyweight> circleMap = new Dictionary<string, IFlyweight>();

    public static IFlyweight GetFlyweight(string color)
    {
        if (!circleMap.ContainsKey(color))
        {
            IFlyweight circle = new ConcreteFlyweightCircle(color);
            circleMap.Add(color, circle);
            Console.WriteLine("Creating circle of color : " + color);
        }
        return circleMap[color];
    }
}
```

### 步骤 5：创建客户类
```csharp
using System;

public class Client
{
    private static readonly string[] colors = { "Red", "Green", "Blue", "White", "Black" };

    public static void Main(string[] args)
    {
        for (int i = 0; i < 20; ++i)
        {
            IFlyweight flyweight = FlyweightFactory.GetFlyweight(GetRandomColor());
            flyweight.Draw(GetRandomX(), GetRandomY(), 100);
        }
    }

    private static string GetRandomColor()
    {
        Random random = new Random();
        return colors[random.Next(colors.Length)];
    }

    private static int GetRandomX()
    {
        Random random = new Random();
        return random.Next(100);
    }

    private static int GetRandomY()
    {
        Random random = new Random();
        return random.Next(100);
    }
}
```

### 运行结果示例
``` cs
Creating circle of color : Black
Circle: Draw() [Color : Black, x : 36, y :71, radius :100
Creating circle of color : Green
Circle: Draw() [Color : Green, x : 27, y :27, radius :100
```


![[Pasted image 20250424203045.jpg]]

## 与其他模式的关系
- 你可以使用[享元模式](https://refactoringguru.cn/design-patterns/flyweight)实现[组合模式](https://refactoringguru.cn/design-patterns/composite)树的共享叶节点以节省内存。
    
- [享元](https://refactoringguru.cn/design-patterns/flyweight)展示了如何生成大量的小型对象， [外观模式](https://refactoringguru.cn/design-patterns/facade)则展示了如何用一个对象来代表整个子系统。
    
- 如果你能将对象的所有共享状态简化为一个享元对象， 那么[享元](https://refactoringguru.cn/design-patterns/flyweight)就和[单例模式](https://refactoringguru.cn/design-patterns/singleton)类似了。 但这两个模式有两个根本性的不同。
    
    1. 只会有一个单例实体， 但是_享元_类可以有多个实体， 各实体的内在状态也可以不同。
    2. _单例_对象可以是可变的。 享元对象是不可变的。