## 策略模式
在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。
在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。
在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

模式结构：
- Context：环境
- Abstract Strategy：抽象策略
- Concrete Strategy：具体策略

**策略模式包含以下几个核心角色：**
- 环境（Context）：维护一个对策略对象的引用，负责将客户端请求委派给具体的策略对象执行。环境类可以通过依赖注入、简单工厂等方式来获取具体策略对象。
- 抽象策略（Abstract Strategy）：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法。
- 具体策略（Concrete Strategy）：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现。

![[Pasted image 20250425160722.jpg]]

1. `IStrategy` 接口：策略接口，定义了具体策略的算法方法
2. `OperationAdd`、`OperationSubtract` 和 `OperationMultiply` 类：具体策略类，实现了策略接口并提供了不同的算法实现
3. `Context` 类：环境类，维护一个对策略对象的引用，并通过这个引用来执行策略算法
4. `StrategyPatternDemo` 类：客户类，演示如何使用策略模式

```cs
using System;

// Strategy: 策略接口
public interface IStrategy
{
    int DoOperation(int num1, int num2);
}

// Concrete Strategy: 具体策略类
// OperationAdd类
public class OperationAdd : IStrategy
{
    public int DoOperation(int num1, int num2)
    {
        return num1 + num2;
    }
}

// OperationSubtract类
public class OperationSubtract : IStrategy
{
    public int DoOperation(int num1, int num2)
    {
        return num1 - num2;
    }
}

// OperationMultiply类
public class OperationMultiply : IStrategy
{
    public int DoOperation(int num1, int num2)
    {
        return num1 * num2;
    }
}

// Context: 环境类
public class Context
{
    private IStrategy strategy;

    public Context(IStrategy strategy)
    {
        this.strategy = strategy;
    }

    public int ExecuteStrategy(int num1, int num2)
    {
        return strategy.DoOperation(num1, num2);
    }
}

// Client: 客户类
public class StrategyPatternDemo
{
    public static void Main(string[] args)
    {
        Context context = new Context(new OperationAdd());
        Console.WriteLine("10 + 5 = " + context.ExecuteStrategy(10, 5));

        context = new Context(new OperationSubtract());
        Console.WriteLine("10 - 5 = " + context.ExecuteStrategy(10, 5));

        context = new Context(new OperationMultiply());
        Console.WriteLine("10 * 5 = " + context.ExecuteStrategy(10, 5));
    }
}
```

执行该程序后，输出结果：
```cs
10 + 5 = 15
10 - 5 = 5
10 * 5 = 50
```

## 与其他模式的关系
- [桥接模式](https://refactoringguru.cn/design-patterns/bridge)、 [状态模式](https://refactoringguru.cn/design-patterns/state)和[策略模式](https://refactoringguru.cn/design-patterns/strategy) （在某种程度上包括[适配器模式](https://refactoringguru.cn/design-patterns/adapter)） 模式的接口非常相似。 实际上， 它们都基于[组合模式](https://refactoringguru.cn/design-patterns/composite)——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。
    
- [命令模式](https://refactoringguru.cn/design-patterns/command)和[策略](https://refactoringguru.cn/design-patterns/strategy)看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。
    - 你可以使用_命令_来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。
    - 另一方面， _策略_通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。
        
- [装饰模式](https://refactoringguru.cn/design-patterns/decorator)可让你更改对象的外表， [策略](https://refactoringguru.cn/design-patterns/strategy)则让你能够改变其本质。
    
- [模板方法模式](https://refactoringguru.cn/design-patterns/template-method)基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 [策略](https://refactoringguru.cn/design-patterns/strategy)基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 _模板方法_在类层次上运作， 因此它是静态的。 _策略_在对象层次上运作， 因此允许在运行时切换行为。
    
- [状态](https://refactoringguru.cn/design-patterns/state)可被视为[策略](https://refactoringguru.cn/design-patterns/strategy)的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 _策略_使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但_状态_模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。
