## 外观模式
外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。

模式结构：
- Facade: 外观角色
- Additional Facade:附加外观 （可选）
- SubSystem:子系统角色
- Client:客户端

**外观模式涉及以下核心角色：**
- **外观（Facade）:**
    - 提供一个简化的接口，封装了系统的复杂性。外观模式的客户端通过与外观对象交互，而无需直接与系统的各个组件打交道。
- **子系统（Subsystem）:**
    - 由多个相互关联的类组成，负责系统的具体功能。外观对象通过调用这些子系统来完成客户端的请求。
- 附加外观（可选,AdditionalFacade）:
    - 可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。
- **客户端（Client）:**
    - 使用外观对象来与系统交互，而不需要了解系统内部的具体实现。

 ![[Pasted image 20250424201645.jpg]]
![[Pasted image 20250424202141.png]]

- **`IShape` 接口**：定义了绘图功能的接口。
- **`Rectangle`、`Square`、`Circle` 类**：实现了 `IShape` 接口，分别代表矩形、正方形和圆形。
- **`ShapeMaker` 外观类**：封装了对各种形状对象的引用和调用，提供了一组简单的方法来绘制不同类型的形状。
- **`AdditionalShapeMaker` 附加外观类**：继承自 `ShapeMaker`，提供了额外的功能（如 `DrawAllShapes` 方法）来一次性绘制所有形状。
- **`FacadePatternDemo` 客户类**：演示了如何使用基础外观类和附加外观类来绘制形状。
### 步骤 1：创建接口
```csharp
// Shape 接口
public interface IShape
{
    void Draw();
}
```

### 步骤 2：创建实现接口的实体类
```csharp
// Rectangle 类
public class Rectangle : IShape
{
    public void Draw()
    {
        System.Console.WriteLine("Rectangle::draw()");
    }
}

// Square 类
public class Square : IShape
{
    public void Draw()
    {
        System.Console.WriteLine("Square::draw()");
    }
}

// Circle 类
public class Circle : IShape
{
    public void Draw()
    {
        System.Console.WriteLine("Circle::draw()");
    }
}
```

### 步骤 3：创建外观类
```csharp
// 外观类
public class ShapeMaker
{
    private IShape circle;
    private IShape rectangle;
    private IShape square;

    public ShapeMaker()
    {
        circle = new Circle();
        rectangle = new Rectangle();
        square = new Square();
    }

    public void DrawCircle()
    {
        circle.Draw();
    }

    public void DrawRectangle()
    {
        rectangle.Draw();
    }

    public void DrawSquare()
    {
        square.Draw();
    }
}
```

### 步骤 4：创建附加外观类
```csharp
// 附加外观类
public class AdditionalShapeMaker : ShapeMaker
{
    public AdditionalShapeMaker() : base()
    {
    }

    public void DrawAllShapes()
    {
        DrawCircle();
        DrawRectangle();
        DrawSquare();
    }
}
```

### 步骤 5：使用外观类和附加外观类
```csharp
using System;

public class FacadePatternDemo
{
    public static void Main(string[] args)
    {
        // 使用基础外观类
        ShapeMaker shapeMaker = new ShapeMaker();
        shapeMaker.DrawCircle();
        shapeMaker.DrawRectangle();
        shapeMaker.DrawSquare();

        Console.WriteLine();

        // 使用附加外观类
        AdditionalShapeMaker additionalShapeMaker = new AdditionalShapeMaker();
        additionalShapeMaker.DrawAllShapes();
    }
}
```

### 执行程序，输出结果
```
Circle::draw()
Rectangle::draw()
Square::draw()

Circle::draw()
Rectangle::draw()
Square::draw()
```

![[Pasted image 20250424201710.jpg]]

##  ## 与其他模式的关系

- [外观模式](https://refactoringguru.cn/design-patterns/facade)为现有对象定义了一个新接口， [适配器模式](https://refactoringguru.cn/design-patterns/adapter)则会试图运用已有的接口。 _适配器_通常只封装一个对象， _外观_通常会作用于整个对象子系统上。
    
- 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用[抽象工厂模式](https://refactoringguru.cn/design-patterns/abstract-factory)来代替[外观](https://refactoringguru.cn/design-patterns/facade)。
    
- [享元模式](https://refactoringguru.cn/design-patterns/flyweight)展示了如何生成大量的小型对象， [外观](https://refactoringguru.cn/design-patterns/facade)则展示了如何用一个对象来代表整个子系统。
    
- [外观](https://refactoringguru.cn/design-patterns/facade)和[中介者模式](https://refactoringguru.cn/design-patterns/mediator)的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。
    - _外观_为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。
    - _中介者_将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。
    
- [外观](https://refactoringguru.cn/design-patterns/facade)类通常可以转换为[单例模式](https://refactoringguru.cn/design-patterns/singleton)类， 因为在大部分情况下一个外观对象就足够了。
    
- [外观](https://refactoringguru.cn/design-patterns/facade)与[代理模式](https://refactoringguru.cn/design-patterns/proxy)的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 _代理_与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与_外观_不同。