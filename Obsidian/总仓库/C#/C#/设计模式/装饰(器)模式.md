## 装饰(器)模式
**装饰(器)模式**是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

模式结构：
- Component: 抽象构件
- ConcreteComponent: 具体构件
- Decorator: 抽象装饰类
- ConcreteDecorator: 具体装饰类

**装饰器模式包含以下几个核心角色：**
- 抽象组件（Component）：定义了原始对象和装饰器对象的公共接口或抽象类，可以是具体组件类的父类或接口。
- 具体组件（Concrete Component）：是被装饰的原始对象，它定义了需要添加新功能的对象。
- 抽象装饰器（Decorator）：继承自抽象组件，它包含了一个抽象组件对象，并定义了与抽象组件相同的接口，同时可以通过组合方式持有其他装饰器对象。
- 具体装饰器（Concrete Decorator）：实现了抽象装饰器的接口，负责向抽象组件添加新的功能。具体装饰器通常会在调用原始对象的方法之前或之后执行自己的操作。

![[Pasted image 20250424200056.jpg]]

- **`IComponent` 抽象构件接口**：定义了绘图功能的接口。
- **`ConcreteComponentCircle` 和 `ConcreteComponentRectangle` 具体构件类**：实现了 `IComponent` 接口，分别代表圆形和矩形。
- **`Decorator` 抽象装饰类**：实现了 `IComponent` 接口，并持有一个 `IComponent` 引用，用于包装具体构件对象。
- **`ConcreteDecoratorRedBorder` 具体装饰类**：继承自 `Decorator` 类，在装饰对象的基础上添加了红色边框的功能。
- **`DecoratorPatternDemo` 客户类**：演示了如何使用装饰器来装饰不同形状的对象，以添加红色边框的效果。
### 步骤 1：创建抽象构件接口
```csharp
// 抽象构件接口
public interface IComponent
{
    void Draw();
}
```

### 步骤 2：创建具体构件类
```csharp
// 具体构件类1：圆形
public class ConcreteComponentCircle : IComponent
{
    public void Draw()
    {
        System.Console.WriteLine("Shape: Circle");
    }
}

// 具体构件类2：矩形
public class ConcreteComponentRectangle : IComponent
{
    public void Draw()
    {
        System.Console.WriteLine("Shape: Rectangle");
    }
}
```

### 步骤 3：创建抽象装饰类
```csharp
// 抽象装饰类
public abstract class Decorator : IComponent
{
    protected IComponent component;

    public Decorator(IComponent component)
    {
        this.component = component;
    }

    public virtual void Draw()
    {
        component.Draw();
    }
}
```

### 步骤 4：创建具体装饰类
```csharp
// 具体装饰类：红色边框装饰器
public class ConcreteDecoratorRedBorder : Decorator
{
    public ConcreteDecoratorRedBorder(IComponent component) : base(component)
    {
    }

    public override void Draw()
    {
        base.Draw();
        SetRedBorder();
    }

    private void SetRedBorder()
    {
        System.Console.WriteLine("Border Color: Red");
    }
}
```

### 步骤 5：使用装饰器来装饰构件对象
```csharp
using System;

public class DecoratorPatternDemo
{
    public static void Main(string[] args)
    {
        IComponent circle = new ConcreteComponentCircle();
        IComponent rectangle = new ConcreteComponentRectangle();

        // 装饰圆形，添加红色边框
        IComponent redCircle = new ConcreteDecoratorRedBorder(circle);

        // 装饰矩形，添加红色边框
        IComponent redRectangle = new ConcreteDecoratorRedBorder(rectangle);

        Console.WriteLine("Circle without decoration:");
        circle.Draw();

        Console.WriteLine("\nCircle with red border decoration:");
        redCircle.Draw();

        Console.WriteLine("\nRectangle with red border decoration:");
        redRectangle.Draw();
    }
}
```

### 步骤 6：执行程序，输出结果
```
Circle without decoration:
Shape: Circle

Circle with red border decoration:
Shape: Circle
Border Color: Red

Rectangle with red border decoration:
Shape: Rectangle
Border Color: Red
```


![[Pasted image 20250424200104.jpg]]
##  与其他模式的关系

- [适配器模式](https://refactoringguru.cn/design-patterns/adapter)可以对已有对象的接口进行修改， [装饰模式](https://refactoringguru.cn/design-patterns/decorator)则能在不改变对象接口的前提下强化对象功能。 此外， _装饰_还支持递归组合， _适配器_则无法实现。
    
- [适配器](https://refactoringguru.cn/design-patterns/adapter)能为被封装对象提供不同的接口， [代理模式](https://refactoringguru.cn/design-patterns/proxy)能为对象提供相同的接口， [装饰](https://refactoringguru.cn/design-patterns/decorator)则能为对象提供加强的接口。
    
- [责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)和[装饰模式](https://refactoringguru.cn/design-patterns/decorator)的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。
    
    [责任链](https://refactoringguru.cn/design-patterns/chain-of-responsibility)的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种_装饰_可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。
    
- [组合模式](https://refactoringguru.cn/design-patterns/composite)和[装饰](https://refactoringguru.cn/design-patterns/decorator)的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。
    
    _装饰_类似于_组合_， 但其只有一个子组件。 此外还有一个明显不同： _装饰_为被封装对象添加了额外的职责， _组合_仅对其子节点的结果进行了 “求和”。
    
    但是， 模式也可以相互合作： 你可以使用_装饰_来扩展_组合_树中特定对象的行为。
    
- 大量使用[组合](https://refactoringguru.cn/design-patterns/composite)和[装饰](https://refactoringguru.cn/design-patterns/decorator)的设计通常可从对于[原型模式](https://refactoringguru.cn/design-patterns/prototype)的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。
    
- [装饰](https://refactoringguru.cn/design-patterns/decorator)可让你更改对象的外表， [策略模式](https://refactoringguru.cn/design-patterns/strategy)则让你能够改变其本质。
    
- [装饰](https://refactoringguru.cn/design-patterns/decorator)和[代理](https://refactoringguru.cn/design-patterns/proxy)有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于_代理_通常自行管理其服务对象的生命周期， 而_装饰_的生成则总是由客户端进行控制。