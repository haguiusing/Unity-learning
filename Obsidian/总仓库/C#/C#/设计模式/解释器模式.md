# 解释器模式
解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。
解释器模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
这种模式被用在 SQL 解析、符号处理引擎等。

模式结构：
- Abstract Expression：抽象表达式
- Terminal Expression：终结符表达式
- Non-terminal Expression：非终结符表达式
- Context：上下文
- Client：客户端

解释器模式包含以下几个主要角色：
- **抽象表达式（Abstract Expression）**：定义了解释器的抽象接口，声明了解释操作的方法，通常是一个抽象类或接口。
- **终结符表达式（Terminal Expression）**：实现了抽象表达式接口的终结符表达式类，用于表示语言中的终结符（如变量、常量等），并实现了对应的解释操作。
- **非终结符表达式（Non-terminal Expression）**：实现了抽象表达式接口的非终结符表达式类，用于表示语言中的非终结符（如句子、表达式等），并实现了对应的解释操作。
- **上下文（Context）**：包含解释器之外的一些全局信息，在解释过程中提供给解释器使用，通常用于存储变量的值、保存解释器的状态等。
- **客户端（Client）**：创建并配置具体的解释器对象，并将需要解释的表达式传递给解释器进行解释。

![[Pasted image 20250424233648.jpg]]

- **`IAbstractExpression` 抽象表达式接口**：定义了解释器模式中所有表达式都需要实现的方法。
- **`TerminalExpression` 终结符表达式类**：实现了抽象表达式接口，用于匹配上下文中的特定数据。
- **`OrExpression` 和 `AndExpression` 非终结符表达式类**：实现了抽象表达式接口，用于组合其他表达式对象，并实现逻辑运算。
- **`Client` 客户端类**：使用表达式对象构建规则，并进行解释。

以下代码的目的是演示解释器模式的结构和用法，而不是实现一个完整或准确的性别判断逻辑。在实际应用中，我们需要更准确和全面的方式来处理这类问题。
## 实例一：
### 步骤 1：创建抽象表达式接口
```csharp
using System;

// 抽象表达式接口
public interface IAbstractExpression
{
    bool Interpret(string context);
}
```

### 步骤 2：创建终结符表达式类
```csharp
// 终结符表达式类
public class TerminalExpression : IAbstractExpression
{
    private string Data;

    public TerminalExpression(string data)
    {
        Data = data;
    }

    public bool Interpret(string context)
    {
        return context.Contains(Data);
    }
}
```

### 步骤 3：创建非终结符表达式类
```csharp
// 非终结符表达式类：或表达式
public class OrExpression : IAbstractExpression
{
    private IAbstractExpression Expr1;
    private IAbstractExpression Expr2;

    public OrExpression(IAbstractExpression expr1, IAbstractExpression expr2)
    {
        Expr1 = expr1;
        Expr2 = expr2;
    }

    public bool Interpret(string context)
    {
        return Expr1.Interpret(context) || Expr2.Interpret(context);
    }
}

// 非终结符表达式类：与表达式
public class AndExpression : IAbstractExpression
{
    private IAbstractExpression Expr1;
    private IAbstractExpression Expr2;

    public AndExpression(IAbstractExpression expr1, IAbstractExpression expr2)
    {
        Expr1 = expr1;
        Expr2 = expr2;
    }

    public bool Interpret(string context)
    {
        return Expr1.Interpret(context) && Expr2.Interpret(context);
    }
}
```

### 步骤 4：创建客户端类
```csharp
using System;

public class Client
{
    // 规则：Robert 和 John 是男性
    public static IAbstractExpression GetMaleExpression()
    {
        IAbstractExpression robert = new TerminalExpression("Robert");
        IAbstractExpression john = new TerminalExpression("John");
        return new OrExpression(robert, john);
    }

    // 规则：Julie 是一个已婚的女性
    public static IAbstractExpression GetMarriedWomanExpression()
    {
        IAbstractExpression julie = new TerminalExpression("Julie");
        IAbstractExpression married = new TerminalExpression("Married");
        return new AndExpression(julie, married);
    }

    public static void Main(string[] args)
    {
        IAbstractExpression isMale = GetMaleExpression();
        IAbstractExpression isMarriedWoman = GetMarriedWomanExpression();

        Console.WriteLine("John is male? " + isMale.Interpret("John"));
        Console.WriteLine("Julie is a married woman? " + isMarriedWoman.Interpret("Married Julie"));
    }
}
```

### 运行结果
```
John is male? True
Julie is a married woman? True
```

- **`Context` 类**：用于存储和传递上下文信息，包括输入字符串和其他可能需要的变量或状态。
- **`IAbstractExpression` 接口**：定义了解释器模式中所有表达式都需要实现的方法，现在这个方法接受一个 `Context` 对象作为参数。
- **`TerminalExpression` 终结符表达式类**：实现了抽象表达式接口，用于匹配上下文中的特定数据。
- **`OrExpression` 和 `AndExpression` 非终结符表达式类**：实现了抽象表达式接口，用于组合其他表达式对象，并实现逻辑运算。
- **`Client` 客户端类**：使用表达式对象构建规则，并进行解释。

## 实例二：
### 步骤 1：创建上下文类
```csharp
using System.Collections.Generic;

// 上下文类
public class Context
{
    public string Input { get; set; }
    public Dictionary<string, bool> Variables { get; set; }

    public Context(string input)
    {
        Input = input;
        Variables = new Dictionary<string, bool>();
    }
}
```

### 步骤 2：更新抽象表达式接口
```csharp
// 抽象表达式接口
public interface IAbstractExpression
{
    bool Interpret(Context context);
}
```

### 步骤 3：更新终结符表达式类
```csharp
// 终结符表达式类
public class TerminalExpression : IAbstractExpression
{
    private string Data;

    public TerminalExpression(string data)
    {
        Data = data;
    }

    public bool Interpret(Context context)
    {
        return context.Input.Contains(Data);
    }
}
```

### 步骤 4：更新非终结符表达式类
```csharp
// 非终结符表达式类：或表达式
public class OrExpression : IAbstractExpression
{
    private IAbstractExpression Expr1;
    private IAbstractExpression Expr2;

    public OrExpression(IAbstractExpression expr1, IAbstractExpression expr2)
    {
        Expr1 = expr1;
        Expr2 = expr2;
    }

    public bool Interpret(Context context)
    {
        return Expr1.Interpret(context) || Expr2.Interpret(context);
    }
}

// 非终结符表达式类：与表达式
public class AndExpression : IAbstractExpression
{
    private IAbstractExpression Expr1;
    private IAbstractExpression Expr2;

    public AndExpression(IAbstractExpression expr1, IAbstractExpression expr2)
    {
        Expr1 = expr1;
        Expr2 = expr2;
    }

    public bool Interpret(Context context)
    {
        return Expr1.Interpret(context) && Expr2.Interpret(context);
    }
}
```

### 步骤 5：更新客户端类
```csharp
using System;

public class Client
{
    // 规则：Robert 和 John 是男性
    public static IAbstractExpression GetMaleExpression()
    {
        IAbstractExpression robert = new TerminalExpression("Robert");
        IAbstractExpression john = new TerminalExpression("John");
        return new OrExpression(robert, john);
    }

    // 规则：Julie 是一个已婚的女性
    public static IAbstractExpression GetMarriedWomanExpression()
    {
        IAbstractExpression julie = new TerminalExpression("Julie");
        IAbstractExpression married = new TerminalExpression("Married");
        return new AndExpression(julie, married);
    }

    public static void Main(string[] args)
    {
        IAbstractExpression isMale = GetMaleExpression();
        IAbstractExpression isMarriedWoman = GetMarriedWomanExpression();

        Context context1 = new Context("John");
        Context context2 = new Context("Married Julie");

        Console.WriteLine("John is male? " + isMale.Interpret(context1));
        Console.WriteLine("Julie is a married woman? " + isMarriedWoman.Interpret(context2));
    }
}
```

### 运行结果
```
John is male? True
Julie is a married woman? True
```