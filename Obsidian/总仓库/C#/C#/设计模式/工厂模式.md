工厂模式（Factory Pattern）是面向对象编程中常用的一种设计模式，属于创建型模式。它提供了一种创建对象的最佳方式，其核心思想是定义一个用于创建对象的接口，但让子类决定实例化哪一个类。工厂模式使得一个类的实例化延迟到其子类。

工厂模式的主要目的是：
1. **封装创建对象的过程**：客户端不需要知道具体的创建细节，只需要知道对象的接口。
2. **提高系统的扩展性**：新增产品类时，不需要修改已有的代码，只需要新增一个具体的工厂类。
3. **解耦对象的创建和使用**：对象的创建和使用分离，使得修改和扩展更加灵活。

工厂模式有几种不同的形式，包括简单工厂模式、工厂方法模式和抽象工厂模式。

### 1. 简单工厂模式（Simple Factory Pattern）
简单工厂模式通过一个工厂类来创建对象。这个工厂类根据传入的参数，决定创建并返回哪个具体类的实例。这种方式简单直观，但随着产品种类的增加，工厂类会变得复杂。
![[Pasted image 20250424155322.jpg]]

模式结构：
1）抽象产品（Abstract Product）：是具体产品们的父类，或者是它们共同都继承的接口。抽象产品可以是一个普通类、抽象类（传送门：Abstract）或接口。
2）具体产品（Concrete Product）：实现抽象产品，定义工厂具体加工出的对象。
3）工厂类（Factory）：工厂类在客户端的直接控制下（Create方法）创建产品对象。

**代码示例**：
```csharp
// 定义产品接口
public interface IProduct
{
    void Show();
}

// 具体产品A类
public class ConcreteProductA : IProduct
{
    public void Show()
    {
        Debug.Log("This is Product A");
    }
}

// 具体产品B类
public class ConcreteProductB : IProduct
{
    public void Show()
    {
        Debug.Log("This is Product B");
    }
}

// 工厂类
public class SimpleFactory
{
    public IProduct CreateProduct(string type)
    {
        if (type == "A")
        {
            return new ConcreteProductA();
        }
        else if (type == "B")
        {
            return new ConcreteProductB();
        }
        return null;
    }
}

// 客户端代码
public class Client
{
    void Start()
    {
        SimpleFactory factory = new SimpleFactory();
        IProduct productA = factory.CreateProduct("A");
        productA.Show();
        IProduct productB = factory.CreateProduct("B");
        productB.Show();
    }
}
```
这种方式在Unity中<font color="#ffc000">常用于根据配置或游戏状态动态创建不同的游戏对象</font>。
![[Pasted image 20250424155445.jpg]]
### 2. 工厂方法模式（Factory Method Pattern）
工厂方法模式将工厂类抽象为一个接口，每个具体的产品类都有对应的工厂类。这种方式提供了更高的灵活性，可以更容易地扩展和替换产品类。
![[Pasted image 20250424160018.jpg]]
模式结构：
- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂
**代码示例**：
```csharp
// 定义产品接口
public interface IProduct
{
    void Show();
}

// 具体产品类
public class ConcreteProductA : IProduct
{
    public void Show()
    {
        Debug.Log("This is Product A");
    }
}

public class ConcreteProductB : IProduct
{
    public void Show()
    {
        Debug.Log("This is Product B");
    }
}

// 工厂接口
public interface IFactory
{
    IProduct CreateProduct();
}

// 具体工厂A类
public class ConcreteFactoryA : IFactory
{
    public IProduct CreateProduct()
    {
        return new ConcreteProductA();
    }
}

// 具体工厂B类
public class ConcreteFactoryB : IFactory
{
    public IProduct CreateProduct()
    {
        return new ConcreteProductB();
    }
}

// 客户端代码
public class Client
{
    void Start()
    {
        IFactory factoryA = new ConcreteFactoryA();
        IProduct productA = factoryA.CreateProduct();
        productA.Show();
        IFactory factoryB = new ConcreteFactoryB();
        IProduct productB = factoryB.CreateProduct();
        productB.Show();
    }
}
```
这种方式在Unity中<font color="#ffc000">适用于需要根据不同的游戏场景或条件创建不同类型对象的情况</font>。
![[Pasted image 20250424160138.jpg]]
### 3. 抽象工厂模式（Abstract Factory Pattern）
抽象工厂模式用于创建一组相关或依赖的对象。它将工厂接口抽象为一个工厂族接口，每个具体的工厂类都对应一个工厂族。
![[Pasted image 20250424160408.jpg]]
模式结构：
- AbstractFactory：抽象工厂
- ConcreteFactory：具体工厂
- AbstractProduct：抽象产品
- Product：具体产品
**代码示例**：
```csharp
// 抽象产品接口
public interface IProductA
{
    void Show();
}

public interface IProductB
{
    void Show();
}

// 具体产品类
public class ConcreteProductA1 : IProductA
{
    public void Show()
    {
        Debug.Log("This is Product A1");
    }
}

public class ConcreteProductA2 : IProductA
{
    public void Show()
    {
        Debug.Log("This is Product A2");
    }
}

public class ConcreteProductB1 : IProductB
{
    public void Show()
    {
        Debug.Log("This is Product B1");
    }
}

public class ConcreteProductB2 : IProductB
{
    public void Show()
    {
        Debug.Log("This is Product B2");
    }
}

// 抽象工厂接口
public interface IFactory
{
    IProductA CreateProductA();
    IProductB CreateProductB();
}

// 具体工厂类
public class ConcreteFactory1 : IFactory
{
    public IProductA CreateProductA()
    {
        return new ConcreteProductA1();
    }
    public IProductB CreateProductB()
    {
        return new ConcreteProductB1();
    }
}

public class ConcreteFactory2 : IFactory
{
    public IProductA CreateProductA()
    {
        return new ConcreteProductA2();
    }
    public IProductB CreateProductB()
    {
        return new ConcreteProductB2();
    }
}

// 客户端代码
public class Client
{
    void Start()
    {
        IFactory factory1 = new ConcreteFactory1();
        IProductA productA1 = factory1.CreateProductA();
        productA1.Show();
        IProductB productB1 = factory1.CreateProductB();
        productB1.Show();
        IFactory factory2 = new ConcreteFactory2();
        IProductA productA2 = factory2.CreateProductA();
        productA2.Show();
        IProductB productB2 = factory2.CreateProductB();
        productB2.Show();
    }
}
```
这种方式在Unity中适用于需要创建一系列相关对象的场景，例如创建不同主题的游戏关卡中的所有对象。
![[Pasted image 20250424160508.jpg]]

这三种工厂模式在Unity游戏开发中都非常有用，可以根据具体的项目需求和设计目标选择合适的模式来实现。