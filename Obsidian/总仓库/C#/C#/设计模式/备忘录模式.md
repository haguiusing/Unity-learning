## 备忘录模式
备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象，备忘录模式属于行为型模式。
备忘录模式允许在不破坏封装性的前提下，不暴露对象实现细节的情况下，保存、捕获和恢复对象的内部状态。

模式结构：
- Memento：备忘录
- Originator：原发器
- Caretaker：负责人
- Client：客户类

备忘录模式包含以下几个主要角色：
- **备忘录（Memento）**：负责存储原发器对象的内部状态。备忘录可以保持原发器的状态的一部分或全部信息。
- **原发器（Originator）**：创建一个备忘录对象，并且可以使用备忘录对象恢复自身的内部状态。原发器通常会在需要保存状态的时候创建备忘录对象，并在需要恢复状态的时候使用备忘录对象。
- **负责人（Caretaker）**：负责保存备忘录对象，但是不对备忘录对象进行操作或检查。负责人只能将备忘录传递给其他对象。
- **客户类（Client）**：演示类

![[memento-20220601-memento.svg]]

1. `Memento` 类：负责保存原发器的内部状态
2. `Originator` 类：负责创建备忘录并可以恢复备忘录
3. `Caretaker` 类：负责保存多个备忘录对象
4. `MementoPatternDemo` 类：作为客户端演示如何使用备忘录模式

```cs
using System;
using System.Collections.Generic;

// Memento: 备忘录类
public class Memento
{
    private string state;

    public Memento(string state)
    {
        this.state = state;
    }

    public string State
    {
        get { return state; }
        set { state = value; }
    }
}

// Originator: 原发器类
public class Originator
{
    private string state;

    public string State
    {
        get { return state; }
        set { state = value; }
    }

    // 创建备忘录
    public Memento CreateMemento()
    {
        return new Memento(state);
    }

    // 恢复备忘录
    public void RestoreMemento(Memento memento)
    {
        state = memento.State;
    }
}

// Caretaker: 负责人类
public class Caretaker
{
    private Stack<Memento> mementoList = new Stack<Memento>();

    // 添加备忘录
    public void AddMemento(Memento memento)
    {
        mementoList.Push(memento);
    }

    // 获取备忘录
    public Memento GetMemento()
    {
        return mementoList.Pop();
    }
}

// Client: 客户类
public class MementoPatternDemo
{
    public static void Main(string[] args)
    {
        Originator originator = new Originator();
        Caretaker caretaker = new Caretaker();

        originator.State = "State #1";
        originator.State = "State #2";
        caretaker.AddMemento(originator.CreateMemento());
        originator.State = "State #3";
        caretaker.AddMemento(originator.CreateMemento());
        originator.State = "State #4";

        Console.WriteLine("Current State: " + originator.State);
        originator.RestoreMemento(caretaker.GetMemento());
        Console.WriteLine("First saved State: " + originator.State);
        originator.RestoreMemento(caretaker.GetMemento());
        Console.WriteLine("Second saved State: " + originator.State);
    }
}
```

执行该程序后，输出结果：
```cs
Current State: State #4
First saved State: State #3
Second saved State: State #2
```

## 与其他模式的关系
- 你可以同时使用[命令模式](https://refactoringguru.cn/design-patterns/command)和[备忘录模式](https://refactoringguru.cn/design-patterns/memento)来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。
    
- 你可以同时使用[备忘录](https://refactoringguru.cn/design-patterns/memento)和[迭代器模式](https://refactoringguru.cn/design-patterns/iterator)来获取当前迭代器的状态， 并且在需要的时候进行回滚。
    
- 有时候[原型模式](https://refactoringguru.cn/design-patterns/prototype)可以作为[备忘录](https://refactoringguru.cn/design-patterns/memento)的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。