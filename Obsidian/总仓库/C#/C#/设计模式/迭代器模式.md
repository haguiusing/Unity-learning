## 迭代器模式
迭代器模式（Iterator Pattern）属于行为型模式，是 Java 和 .Net 编程环境中非常常用的设计模式。
迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

模式结构：
- Iterator：迭代器接口
- Concrete Iterator：具体迭代器
- Aggregate/Collection：聚合对象接口
- Concrete Aggregate：具体聚合对象
- Client：客户端

迭代器模式包含以下几个主要角色：
- **迭代器接口（Iterator）**：定义了访问和遍历聚合对象中各个元素的方法，通常包括获取下一个元素、判断是否还有元素、获取当前位置等方法。
- **具体迭代器（Concrete Iterator）**：实现了迭代器接口，负责对聚合对象进行遍历和访问，同时记录遍历的当前位置。
- **聚合对象接口（Aggregate/Collection）**：定义了创建迭代器对象的接口，通常包括一个工厂方法用于创建迭代器对象。
- **具体聚合对象（Concrete Aggregate/Collections）**：实现了聚合对象接口，负责创建具体的迭代器对象，并提供需要遍历的数据。
- **客户端** （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。
    客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。

![[Pasted image 20250425000112.png]]

1. `IIterator` 接口定义了迭代器的基本操作
2. `NameIterator` 是具体的迭代器实现，负责遍历聚合对象
3. `IAggregate` 是聚合对象的接口，提供创建迭代器的方法
4. `NameRepository` 是具体的聚合对象，实现了聚合接口并包含了实际的数据
5. `IteratorPatternDemo` 是客户端代码，演示如何使用迭代器模式

```csharp
using System;

// Iterator 接口
public interface IIterator
{
    bool HasNext();
    object Next();
}

// Concrete Iterator 具体迭代器
public class NameIterator : IIterator
{
    private readonly string[] names;
    private int index;

    public NameIterator(string[] names)
    {
        this.names = names;
        index = 0;
    }

    public bool HasNext()
    {
        return index < names.Length;
    }

    public object Next()
    {
        if (HasNext())
        {
            return names[index++];
        }
        return null;
    }
}

// Aggregate/Collection 聚合对象接口
public interface IAggregate
{
    IIterator CreateIterator();
}

// Concrete Aggregate 具体聚合对象
public class NameRepository : IAggregate
{
    public string[] Names { get; } = { "Robert", "John", "Julie", "Lora" };

    public IIterator CreateIterator()
    {
        return new NameIterator(Names);
    }
}

// Client 客户端
public class IteratorPatternDemo
{
    public static void Main(string[] args)
    {
        NameRepository namesRepository = new NameRepository();

        IIterator iterator = namesRepository.CreateIterator();
        while (iterator.HasNext())
        {
            string name = (string)iterator.Next();
            Console.WriteLine("Name : " + name);
        }
    }
}
```

执行该程序后，输出结果与原始 Java 版本相同：
```cs
Name : Robert
Name : John
Name : Julie
Name : Lora
```

##  与其他模式的关系
- 你可以使用[迭代器模式](https://refactoringguru.cn/design-patterns/iterator)来遍历[组合模式](https://refactoringguru.cn/design-patterns/composite)树。
    
- 你可以同时使用[工厂方法模式](https://refactoringguru.cn/design-patterns/factory-method)和[迭代器](https://refactoringguru.cn/design-patterns/iterator)来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。
    
- 你可以同时使用[备忘录模式](https://refactoringguru.cn/design-patterns/memento)和[迭代器](https://refactoringguru.cn/design-patterns/iterator)来获取当前迭代器的状态， 并且在需要的时候进行回滚。
    
- 可以同时使用[访问者模式](https://refactoringguru.cn/design-patterns/visitor)和[迭代器](https://refactoringguru.cn/design-patterns/iterator)来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。
    

##  代码示例