## 桥接模式
**桥接模式**是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。

模块结构：
- Abstraction：抽象类
- RefinedAbstraction：扩充抽象类/精确抽象(可选)
- Implementor：实现类接口
- ConcreteImplementor：具体实现类
- Client：客户类

以下是桥接模式的几个关键角色：
- 抽象（Abstraction）：定义抽象接口，通常包含对实现接口的引用。
- 扩展抽象（Refined Abstraction）：对抽象的扩展，可以是抽象类的子类或具体实现类。
- 实现（Implementor）：定义实现接口，提供基本操作的接口。
- 具体实现（Concrete Implementor）：实现实现接口的具体类。

![[Pasted image 20250424185205.jpg]]

- `IImplementor` 是实现类接口，定义了绘图功能的通用方法。
- `RedCircleImplementor` 和 `GreenCircleImplementor` 是具体实现类，分别实现了 `IImplementor` 接口，提供了绘制红色和绿色圆形的具体方法。
- `Abstraction` 是抽象类，持有一个 `IImplementor` 类型的对象，并定义了一个抽象方法 `Draw`。
- `RefinedAbstraction` 是扩充抽象类，继承自 `Abstraction`，实现了 `Draw` 方法。在 `Draw` 方法中，调用了 `IImplementor` 对象的 `DrawCircle` 方法来绘制圆形。
- `Client` 是客户类，创建了不同颜色的 `RefinedAbstraction` 对象，并调用它们的 `Draw` 方法来绘制圆形。
### 步骤 1：创建桥接实现接口
```csharp
// 实现类接口
public interface IImplementor
{
    void DrawCircle(int radius, int x, int y);
}
```

### 步骤 2：创建实现 `IDrawAPI` 接口的实体桥接实现类
```csharp
// 具体实现类1
public class RedCircleImplementor : IImplementor
{
    public void DrawCircle(int radius, int x, int y)
    {
        System.Console.WriteLine($"Drawing Circle[ color: red, radius: {radius}, x: {x}, y: {y}]");
    }
}

// 具体实现类2
public class GreenCircleImplementor : IImplementor
{
    public void DrawCircle(int radius, int x, int y)
    {
        System.Console.WriteLine($"Drawing Circle[ color: green, radius: {radius}, x: {x}, y: {y}]");
    }
}
```

### 步骤 3：使用 `IDrawAPI` 接口创建抽象类 `Shape`
```csharp
// 抽象类
public abstract class Abstraction
{
    protected IImplementor Implementor;

    public Abstraction(IImplementor implementor)
    {
        Implementor = implementor;
    }

    public abstract void Draw();
}
```

### 步骤 4：创建实现 `Shape` 抽象类的实体类
```csharp
// 扩充抽象类
public class RefinedAbstraction : Abstraction
{
    private int X { get; }
    private int Y { get; }
    private int Radius { get; }

    public RefinedAbstraction(int x, int y, int radius, IImplementor implementor) : base(implementor)
    {
        X = x;
        Y = y;
        Radius = radius;
    }

    public override void Draw()
    {
        Implementor.DrawCircle(Radius, X, Y);
    }
}
```

### 步骤 5：使用 `Shape` 和 `IDrawAPI` 类画出不同颜色的圆
```csharp
// 客户类
public class Client
{
    public static void Main(string[] args)
    {
        IImplementor redCircleImplementor = new RedCircleImplementor();
        IImplementor greenCircleImplementor = new GreenCircleImplementor();

        RefinedAbstraction redCircle = new RefinedAbstraction(100, 100, 10, redCircleImplementor);
        RefinedAbstraction greenCircle = new RefinedAbstraction(100, 100, 10, greenCircleImplementor);

        redCircle.Draw();
        greenCircle.Draw();
    }
}
```

### 步骤 6：执行程序，输出结果
``` cs
Drawing Circle[ color: red, radius: 10, x: 100, y: 100]
Drawing Circle[ color: green, radius: 10, x: 100, y: 100]
```

## 不使用`RefinedAbstraction`
### 具体实现类代码（保持不变）
```csharp
public class RedCircleImplementor : IImplementor
{
    public void DrawCircle(int radius, int x, int y)
    {
        System.Console.WriteLine($"Drawing Circle[ color: red, radius: {radius}, x: {x}, y: {y}]");
    }
}

public class GreenCircleImplementor : IImplementor
{
    public void DrawCircle(int radius, int x, int y)
    {
        System.Console.WriteLine($"Drawing Circle[ color: green, radius: {radius}, x: {x}, y: {y}]");
    }
}
```

### 抽象类的修改（清除抽象类）
```csharp
public class Abstraction
{
    protected IImplementor Implementor;

    public Abstraction(IImplementor implementor)
    {
        Implementor = implementor;
    }

    public abstract void Draw();
}
```
### 客户类代码（不使用`RefinedAbstraction`）
```csharp
public class Client
{
    public static void Main(string[] args)
    {
        // 创建不同颜色的圆的实现类
        IImplementor redCircleImplementor = new RedCircleImplementor();
        IImplementor greenCircleImplementor = new GreenCircleImplementor();

        // 创建抽象类实例并关联不同的实现类
        Abstraction redCircle = new Abstraction(redCircleImplementor);
        Abstraction greenCircle = new Abstraction(greenCircleImplementor);

        // 调用绘制方法
        redCircle.Draw();
        greenCircle.Draw();
    }
}
```
### 输出结果
```
Drawing Circle[ color: red, radius: 10, x: 100, y: 100]
Drawing Circle[ color: green, radius: 10, x: 100, y: 100]
```
### 说明
- 在这种情况下，`Abstraction`抽象类没有具体的实现细节，而是依赖于`IImplementor`接口来完成绘制操作。
    
- 如果需要绘制不同参数的圆（如不同的半径、位置等），可以在`Abstraction`类中添加相应的属性，并在构造函数中初始化这些属性。
    
- 这种方式仍然遵循桥接模式的核心思想，将抽象与实现分离，使它们可以独立变化。

## 与其他模式的关系
- [桥接模式](https://refactoringguru.cn/design-patterns/bridge)通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， [适配器模式](https://refactoringguru.cn/design-patterns/adapter)通常在已有程序中使用， 让相互不兼容的类能很好地合作。
### 桥接模式与适配器模式配合的代码演示：
#### 目标接口（Target）
定义客户端所期望的接口。
```csharp
public interface ITarget
{
    void Draw();
}
```

#### 适配器类（Adapter）
将被适配者的接口转换为目标接口。
```csharp
public class Adapter : ITarget
{
    private readonly IImplementor _implementor;

    public Adapter(IImplementor implementor)
    {
        _implementor = implementor;
    }

    public void Draw()
    {
        _implementor.DrawCircle(10, 100, 100);
    }
}
```

#### 被适配者接口（Adaptee）
定义被适配者的接口。
```csharp
public interface IAdaptee
{
    void DrawCircle(int radius, int x, int y);
}
```

#### 实现类接口（Implementor）
定义实现部分的接口。
```csharp
public interface IImplementor : IAdaptee
{
}
```

#### 具体实现类（ConcreteImplementor）
实现实现类接口的具体类。
```csharp
public class ConcreteImplementor : IImplementor
{
    public void DrawCircle(int radius, int x, int y)
    {
        System.Console.WriteLine($"Drawing Circle[ color: blue, radius: {radius}, x: {x}, y: {y}]");
    }
}
```

#### 抽象类（Abstraction）
定义抽象部分的接口。
```csharp
public abstract class Abstraction
{
    protected IImplementor Implementor;

    public Abstraction(IImplementor implementor)
    {
        Implementor = implementor;
    }

    public abstract void Draw();
}
```

#### 扩充抽象类（RefinedAbstraction）
扩充抽象类，实现抽象类的接口。
```csharp
public class RefinedAbstraction : Abstraction
{
    public RefinedAbstraction(IImplementor implementor) : base(implementor)
    {
    }

    public override void Draw()
    {
        Implementor.DrawCircle(10, 100, 100);
    }
}
```

#### 客户类（Client）
使用适配器和桥接模式来绘制图形。
```csharp
using System;

public class Client
{
    public static void Main(string[] args)
    {
        // 使用桥接模式
        IImplementor implementor = new ConcreteImplementor();
        Abstraction abstraction = new RefinedAbstraction(implementor);
        abstraction.Draw();

        // 使用适配器模式
        ITarget adapter = new Adapter(implementor);
        adapter.Draw();
    }
}
```

#### 运行结果
```cs
Drawing Circle[ color: blue, radius: 10, x: 100, y: 100]
Drawing Circle[ color: blue, radius: 10, x: 100, y: 100]
```

    
- [桥接](https://refactoringguru.cn/design-patterns/bridge)、 [状态模式](https://refactoringguru.cn/design-patterns/state)和[策略模式](https://refactoringguru.cn/design-patterns/strategy) （在某种程度上包括[适配器](https://refactoringguru.cn/design-patterns/adapter)） 模式的接口非常相似。 实际上， 它们都基于[组合模式](https://refactoringguru.cn/design-patterns/composite)——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。

    
- 你可以将[抽象工厂模式](https://refactoringguru.cn/design-patterns/abstract-factory)和[桥接](https://refactoringguru.cn/design-patterns/bridge)搭配使用。 如果由_桥接_定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， _抽象工厂_可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。

### 抽象工厂模式与桥接模式配合的代码演示：

#### 桥接模式部分

##### 1. 实现部分（Implementation）的接口
```csharp
// 实现类接口
public interface IImplementor
{
    void DrawCircle(int radius, int x, int y);
    void DrawSquare(int size, int x, int y);
}
```

##### 2. 具体实现类
```csharp
// 具体实现类1：红色实现
public class RedImplementor : IImplementor
{
    public void DrawCircle(int radius, int x, int y)
    {
        Console.WriteLine($"Drawing Circle[ color: red, radius: {radius}, x: {x}, y: {y}]");
    }

    public void DrawSquare(int size, int x, int y)
    {
        Console.WriteLine($"Drawing Square[ color: red, size: {size}, x: {x}, y: {y}]");
    }
}

// 具体实现类2：绿色实现
public class GreenImplementor : IImplementor
{
    public void DrawCircle(int radius, int x, int y)
    {
        Console.WriteLine($"Drawing Circle[ color: green, radius: {radius}, x: {x}, y: {y}]");
    }

    public void DrawSquare(int size, int x, int y)
    {
        Console.WriteLine($"Drawing Square[ color: green, size: {size}, x: {x}, y: {y}]");
    }
}
```

##### 3. 抽象部分
```csharp
// 抽象类
public abstract class Abstraction
{
    protected IImplementor Implementor;

    public Abstraction(IImplementor implementor)
    {
        Implementor = implementor;
    }

    public abstract void Draw();
}
```

##### 4. 扩充抽象类
```csharp
// 扩充抽象类：圆形
public class CircleAbstraction : Abstraction
{
    private int X { get; }
    private int Y { get; }
    private int Radius { get; }

    public CircleAbstraction(int x, int y, int radius, IImplementor implementor) : base(implementor)
    {
        X = x;
        Y = y;
        Radius = radius;
    }

    public override void Draw()
    {
        Implementor.DrawCircle(Radius, X, Y);
    }
}

// 扩充抽象类：正方形
public class SquareAbstraction : Abstraction
{
    private int X { get; }
    private int Y { get; }
    private int Size { get; }

    public SquareAbstraction(int x, int y, int size, IImplementor implementor) : base(implementor)
    {
        X = x;
        Y = y;
        Size = size;
    }

    public override void Draw()
    {
        Implementor.DrawSquare(Size, X, Y);
    }
}
```

#### 抽象工厂模式部分
##### 1. 抽象产品接口
```csharp
// 抽象产品接口
public interface IShape
{
    void Draw();
}
```

##### 2. 具体产品类
```csharp
// 具体产品类：圆形
public class CircleShape : IShape
{
    private readonly CircleAbstraction _abstraction;

    public CircleShape(int x, int y, int radius, IImplementor implementor)
    {
        _abstraction = new CircleAbstraction(x, y, radius, implementor);
    }

    public void Draw()
    {
        _abstraction.Draw();
    }
}

// 具体产品类：正方形
public class SquareShape : IShape
{
    private readonly SquareAbstraction _abstraction;

    public SquareShape(int x, int y, int size, IImplementor implementor)
    {
        _abstraction = new SquareAbstraction(x, y, size, implementor);
    }

    public void Draw()
    {
        _abstraction.Draw();
    }
}
```

##### 3. 抽象工厂接口
```csharp
// 抽象工厂接口
public interface IAbstractFactory
{
    IShape CreateCircle();
    IShape CreateSquare();
}
```

##### 4. 具体工厂类
```csharp
// 具体工厂类：红色工厂
public class RedFactory : IAbstractFactory
{
    public IShape CreateCircle()
    {
        return new CircleShape(100, 100, 10, new RedImplementor());
    }

    public IShape CreateSquare()
    {
        return new SquareShape(100, 100, 50, new RedImplementor());
    }
}

// 具体工厂类：绿色工厂
public class GreenFactory : IAbstractFactory
{
    public IShape CreateCircle()
    {
        return new CircleShape(100, 100, 10, new GreenImplementor());
    }

    public IShape CreateSquare()
    {
        return new SquareShape(100, 100, 50, new GreenImplementor());
    }
}
```

#### 客户端代码
```csharp
using System;

public class Client
{
    public static void Main(string[] args)
    {
        // 红色工厂创建形状
        IAbstractFactory redFactory = new RedFactory();
        IShape redCircle = redFactory.CreateCircle();
        IShape redSquare = redFactory.CreateSquare();

        redCircle.Draw();
        redSquare.Draw();

        // 绿色工厂创建形状
        IAbstractFactory greenFactory = new GreenFactory();
        IShape greenCircle = greenFactory.CreateCircle();
        IShape greenSquare = greenFactory.CreateSquare();

        greenCircle.Draw();
        greenSquare.Draw();
    }
}
```

#### 运行结果
``` cs
Drawing Circle[ color: red, radius: 10, x: 100, y: 100]
Drawing Square[ color: red, size: 50, x: 100, y: 100]
Drawing Circle[ color: green, radius: 10, x: 100, y: 100]
Drawing Square[ color: green, size: 50, x: 100, y: 100]
```

    
- 你可以结合使用[生成器模式](https://refactoringguru.cn/design-patterns/builder)和[桥接模式](https://refactoringguru.cn/design-patterns/bridge)： _主管_类负责抽象工作， 各种不同的_生成器_负责_实现_工作。

### 生成器模式和桥接模式融合的代码演示：

#### 实现部分（Implementation）
```csharp
// 实现类接口
public interface IImplementor
{
    void DrawCircle(int radius, int x, int y);
    void DrawSquare(int size, int x, int y);
}

// 具体实现类1：红色实现
public class RedImplementor : IImplementor
{
    public void DrawCircle(int radius, int x, int y)
    {
        System.Console.WriteLine($"Drawing Circle[ color: red, radius: {radius}, x: {x}, y: {y}]");
    }

    public void DrawSquare(int size, int x, int y)
    {
        System.Console.WriteLine($"Drawing Square[ color: red, size: {size}, x: {x}, y: {y}]");
    }
}

// 具体实现类2：绿色实现
public class GreenImplementor : IImplementor
{
    public void DrawCircle(int radius, int x, int y)
    {
        System.Console.WriteLine($"Drawing Circle[ color: green, radius: {radius}, x: {x}, y: {y}]");
    }

    public void DrawSquare(int size, int x, int y)
    {
        System.Console.WriteLine($"Drawing Square[ color: green, size: {size}, x: {x}, y: {y}]");
    }
}
```

#### 抽象部分
```csharp
// 抽象类
public abstract class Abstraction
{
    protected IImplementor Implementor;

    public Abstraction(IImplementor implementor)
    {
        Implementor = implementor;
    }

    public abstract void Draw();
}

// 扩充抽象类：圆形
public class CircleAbstraction : Abstraction
{
    private int X { get; }
    private int Y { get; }
    private int Radius { get; }

    public CircleAbstraction(int x, int y, int radius, IImplementor implementor) : base(implementor)
    {
        X = x;
        Y = y;
        Radius = radius;
    }

    public override void Draw()
    {
        Implementor.DrawCircle(Radius, X, Y);
    }
}

// 扩充抽象类：正方形
public class SquareAbstraction : Abstraction
{
    private int X { get; }
    private int Y { get; }
    private int Size { get; }

    public SquareAbstraction(int x, int y, int size, IImplementor implementor) : base(implementor)
    {
        X = x;
        Y = y;
        Size = size;
    }

    public override void Draw()
    {
        Implementor.DrawSquare(Size, X, Y);
    }
}
```

#### 生成器模式部分
```csharp
// 产品角色：图形产品
public class ShapeProduct
{
    public IImplementor Implementor { get; set; }
    public string ShapeType { get; set; }
    public int X { get; set; }
    public int Y { get; set; }
    public int Radius { get; set; }
    public int Size { get; set; }

    public void Draw()
    {
        if (ShapeType == "Circle")
        {
            Implementor.DrawCircle(Radius, X, Y);
        }
        else if (ShapeType == "Square")
        {
            Implementor.DrawSquare(Size, X, Y);
        }
    }
}

// 抽象建造者
public abstract class Builder
{
    protected ShapeProduct shapeProduct;

    public ShapeProduct Product
    {
        get { return shapeProduct; }
    }

    public abstract void BuildShape(string shapeType);
    public abstract void BuildPosition(int x, int y);
    public abstract void BuildSize(int size);
}

// 具体建造者
public class ConcreteBuilder : Builder
{
    public ConcreteBuilder()
    {
        shapeProduct = new ShapeProduct();
    }

    public override void BuildShape(string shapeType)
    {
        shapeProduct.ShapeType = shapeType;
    }

    public override void BuildPosition(int x, int y)
    {
        shapeProduct.X = x;
        shapeProduct.Y = y;
    }

    public override void BuildSize(int size)
    {
        if (shapeProduct.ShapeType == "Circle")
        {
            shapeProduct.Radius = size;
        }
        else if (shapeProduct.ShapeType == "Square")
        {
            shapeProduct.Size = size;
        }
    }
}

// 指挥者
public class Director
{
    private Builder builder;

    public Director(Builder builder)
    {
        this.builder = builder;
    }

    public void Construct(string shapeType, int x, int y, int size)
    {
        builder.BuildShape(shapeType);
        builder.BuildPosition(x, y);
        builder.BuildSize(size);
    }
}
```

#### 客户类
```csharp
using System;

public class Client
{
    public static void Main(string[] args)
    {
        // 创建红色实现和绿色实现
        IImplementor redImplementor = new RedImplementor();
        IImplementor greenImplementor = new GreenImplementor();

        // 创建建造者和指挥者
        Builder builder = new ConcreteBuilder();
        Director director = new Director(builder);

        // 构建红色圆形
        director.Construct("Circle", 100, 100, 10);
        builder.Product.Implementor = redImplementor;
        builder.Product.Draw();

        // 构建绿色正方形
        director.Construct("Square", 100, 100, 50);
        builder.Product.Implementor = greenImplementor;
        builder.Product.Draw();
    }
}
```

#### 运行结果
``` cs
Drawing Circle[ color: red, radius: 10, x: 100, y: 100]
Drawing Square[ color: green, size: 50, x: 100, y: 100]
```