## 访问者模式
在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

模式结构：
- Visitor：访问者
- Concrete Visitor：具体访问者
- Element：元素
- Concrete Element：具体元素
- Object Structure：对象结构
- Client：客户端

包含的几个主要角色
- **访问者（Visitor）**：
    - 定义了访问元素的接口。
- **具体访问者（Concrete Visitor）**：
    - 实现访问者接口，提供对每个具体元素类的访问和相应操作。
- **元素（Element）**：
    - 定义了一个接受访问者的方法。
- **具体元素（Concrete Element）**：
    - 实现元素接口，提供一个`accept`方法，允许访问者访问并操作。
- **对象结构（Object Structure）（可选）**：
    - 定义了如何组装具体元素，如一个组合类。
- **客户端（Client）（可选）**：
    - 使用访问者模式对对象结构进行操作。

![[Pasted image 20250425162231.jpg]]

1. `IComputerPart` 接口：元素接口，定义了 `Accept` 方法，用于接受访问者
2. `Keyboard`、`Monitor`、`Mouse` 和 `Computer` 类：具体元素类，实现了 `IComputerPart` 接口
3. `IComputerPartVisitor` 接口：访问者接口，定义了对不同具体元素的访问方法
4. `ComputerPartDisplayVisitor` 类：具体访问者类，实现了访问者接口并为每个具体元素提供访问逻辑
5. `VisitorPatternDemo` 类：客户类，演示如何使用访问者模式

```cs
using System;

// Element: 元素接口
public interface IComputerPart
{
    void Accept(IComputerPartVisitor computerPartVisitor);
}

// Concrete Element: 具体元素类
// Keyboard类
public class Keyboard : IComputerPart
{
    public void Accept(IComputerPartVisitor computerPartVisitor)
    {
        computerPartVisitor.Visit(this);
    }
}

// Monitor类
public class Monitor : IComputerPart
{
    public void Accept(IComputerPartVisitor computerPartVisitor)
    {
        computerPartVisitor.Visit(this);
    }
}

// Mouse类
public class Mouse : IComputerPart
{
    public void Accept(IComputerPartVisitor computerPartVisitor)
    {
        computerPartVisitor.Visit(this);
    }
}

// 对象结构类
// Computer类
public class Computer : IComputerPart
{
    private IComputerPart[] parts;

    public Computer()
    {
        parts = new IComputerPart[] { new Mouse(), new Keyboard(), new Monitor() };
    }

    public void Accept(IComputerPartVisitor computerPartVisitor)
    {
        foreach (IComputerPart part in parts)
        {
            part.Accept(computerPartVisitor);
        }
        computerPartVisitor.Visit(this);
    }
}

// Visitor: 访问者接口
public interface IComputerPartVisitor
{
    void Visit(Computer computer);
    void Visit(Mouse mouse);
    void Visit(Keyboard keyboard);
    void Visit(Monitor monitor);
}

// Concrete Visitor: 具体访问者类
// ComputerPartDisplayVisitor类
public class ComputerPartDisplayVisitor : IComputerPartVisitor
{
    public void Visit(Computer computer)
    {
        Console.WriteLine("Displaying Computer.");
    }

    public void Visit(Mouse mouse)
    {
        Console.WriteLine("Displaying Mouse.");
    }

    public void Visit(Keyboard keyboard)
    {
        Console.WriteLine("Displaying Keyboard.");
    }

    public void Visit(Monitor monitor)
    {
        Console.WriteLine("Displaying Monitor.");
    }
}

// Client: 客户类
public class VisitorPatternDemo
{
    public static void Main(string[] args)
    {
        IComputerPart computer = new Computer();
        computer.Accept(new ComputerPartDisplayVisitor());
    }
}
```


执行该程序后，输出结果：
```cs
Displaying Mouse.
Displaying Keyboard.
Displaying Monitor.
Displaying Computer.
```

## 与其他模式的关系

- 你可以将[访问者模式](https://refactoringguru.cn/design-patterns/visitor)视为[命令模式](https://refactoringguru.cn/design-patterns/command)的加强版本， 其对象可对不同类的多种对象执行操作。
    
- 你可以使用[访问者](https://refactoringguru.cn/design-patterns/visitor)对整个[组合模式](https://refactoringguru.cn/design-patterns/composite)树执行操作。
    
- 可以同时使用[访问者](https://refactoringguru.cn/design-patterns/visitor)和[迭代器模式](https://refactoringguru.cn/design-patterns/iterator)来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。
