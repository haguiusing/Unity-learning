主入口：![[ILRuntimeMain.cs]]
![[Lesson18.cs]]

### ILRuntime中使用序列化库
序列化库在我们开发中经常会用到，比如之前我们学过的 LitJson、Protobuf。但是这些库都存在于主工程中，所以在ILRuntime中使用序列化库需要对其进行修改。

LitJson库获取：Demo工程中就有修改好的LitJson
Protobuf库获取：https://gitee.com/cyecp/protobuf-net
![[Pasted image 20250603191351.png]]
注意：改写序列化库时，不能通过Activator来创建实例。

在热更工程声明结构体测试类
```cs
public class Lesson19_Test
{
    public int testInt;
    public string testStr;
    public List<int> testList;
    public Dictionary<string,int> testDictionary;
}
```

在ILRuntimeMain实例化测试类，进行序列化反序列化
```cs
Lesson19_Test test = new Lesson19_Test();
test.testInt = 99;
test.testStr = "韬韬韬";
test.testList = new List<int>() { 1, 2, 3, 4, 5 };
test.testDictionary = new Dictionary<string, int>() { { "1", 99 }, { "2", 88 }, { "3", 77 } };

//序列化Json字符串
string str = JsonMapper.ToJson(test);
Debug.Log(str);

//反序列化
Lesson19_Test test2 = JsonMapper.ToObject<Lesson19_Test>(str);
Debug.Log(test2.testInt);
Debug.Log(test2.testStr);
```

重新生成后直接运行会有报错，MissingMethodException: Default constructor not found for type，要进行以下处理

#### 使用改好的LitJson库
1. 初始化时注册：`LitJson.JsonMapper.RegisterILRuntimeCLRRedirection(appDomain)`
2. 正常使用LitJson进行序列化反序列化：
    - 序列化：`JsonMapper.ToJson(对象)`
    - 反序列化：`JsonMapper.ToObject

在ILruntimeManage初始化注册LitJson
```cs
// 注册Litjson
LitJson.JsonMapper.RegisterILRuntimeCLRRedirection(appDomain);
```

重新运行可以正常序列化反序列化了

### 如何自己改相关库
1. 正确创建热更类型的实例（利用之前反射相关的创建方式）
2. 获取泛型容器类的真实热更类型
3. 序列化子对象
4. 重定向泛型方法

查看去查看LitJson修改后的源码来分析加了哪些内容

点击转到RegisterILRuntimeCLRRedirection方法的定义，进去看做了什么,发现主要还是<font color="#ffff00">CLR重定向</font>
```cs
public unsafe static void RegisterILRuntimeCLRRedirection(ILRuntime.Runtime.Enviorment.AppDomain appdomain)
{
    foreach(var i in typeof(JsonMapper).GetMethods())
    {
        if(i.Name == "ToObject" && i.IsGenericMethodDefinition)
        {
            var param = i.GetParameters();
            if(param[0].ParameterType == typeof(string))
            {
                appdomain.RegisterCLRMethodRedirection(i, JsonToObject);
            }
            else if(param[0].ParameterType == typeof(JsonReader))
            {
                appdomain.RegisterCLRMethodRedirection(i, JsonToObject2);
            }
            else if (param[0].ParameterType == typeof(TextReader))
            {
                appdomain.RegisterCLRMethodRedirection(i, JsonToObject3);
            }
        }
    }
}
```

```cs
public unsafe static StackObject* JsonToObject(ILIntepreter intp, StackObject* esp, IList<object> mStack, CLRMethod method, bool isNewObj)
{
    ILRuntime.Runtime.Enviorment.AppDomain __domain = intp.AppDomain;
    StackObject* ptr_of_this_method;
    StackObject* __ret = ILIntepreter.Minus(esp, 1);
    ptr_of_this_method = ILIntepreter.Minus(esp, 1);
    System.String json = (System.String)typeof(System.String).CheckCLRTypes(StackObject.ToObject(ptr_of_this_method, __domain, mStack));
    intp.Free(ptr_of_this_method);
    var type = method.GenericArguments[0].ReflectionType;
    var result_of_this_method = ReadValue(type, new JsonReader(json));

    return ILIntepreter.PushObject(__ret, mStack, result_of_this_method);
}

public unsafe static StackObject* JsonToObject2(ILIntepreter intp, StackObject* esp, IList<object> mStack, CLRMethod method, bool isNewObj)
{
    ILRuntime.Runtime.Enviorment.AppDomain __domain = intp.AppDomain;
    StackObject* ptr_of_this_method;
    StackObject* __ret = ILIntepreter.Minus(esp, 1);
    ptr_of_this_method = ILIntepreter.Minus(esp, 1);
    JsonReader json = (JsonReader)typeof(JsonReader).CheckCLRTypes(StackObject.ToObject(ptr_of_this_method, __domain, mStack));
    intp.Free(ptr_of_this_method);
    var type = method.GenericArguments[0].ReflectionType;
    var result_of_this_method = ReadValue(type, json);

    return ILIntepreter.PushObject(__ret, mStack, result_of_this_method);
}

public unsafe static StackObject* JsonToObject3(ILIntepreter intp, StackObject* esp, IList<object> mStack, CLRMethod method, bool isNewObj)
{
    ILRuntime.Runtime.Enviorment.AppDomain __domain = intp.AppDomain;
    StackObject* ptr_of_this_method;
    StackObject* __ret = ILIntepreter.Minus(esp, 1);
    ptr_of_this_method = ILIntepreter.Minus(esp, 1);
    TextReader json = (TextReader)typeof(TextReader).CheckCLRTypes(StackObject.ToObject(ptr_of_this_method, __domain, mStack));
    intp.Free(ptr_of_this_method);
    var type = method.GenericArguments[0].ReflectionType;
    var result_of_this_method = ReadValue(type, new JsonReader(json));

    return ILIntepreter.PushObject(__ret, mStack, result_of_this_method);
}
```

### 总结
ILRuntime在使用第三方库时，为了能够正常对热更工程中声明的类对象进行使用，我们往往需要对其进行修改。修改第三方库对于大家来说可能有一定难度，所以首先去ILRuntime的群和社区中去找找有没有别人做好的。如果没有再尝试自己修改。