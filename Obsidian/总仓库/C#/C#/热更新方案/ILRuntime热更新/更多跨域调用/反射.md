主入口：![[ILRuntimeMain.cs]]
![[Lesson17.cs]]
### 在ILRuntime工程中使用反射
按照反射的规则正常使用即可，和C#中反射没有任何区别。

### 在Unity工程中反射ILRuntime工程中内容
回顾之前在ILRuntime热更工程创建的Lesson4_Test，给他加一个公共成员变量，重新生成
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace HotFix_Project
{
    class Lesson4_Test
    {
        #region 成员变量
        private string str;
        public int TestInt;
        #endregion

        #region 成员属性
        public string Str
        {
            get
            {
                return str;
            }
            set
            {
                str = value;
            }
        }
        #endregion

        #region 构造函数
        public Lesson4_Test()
        {

        }

        public Lesson4_Test(string str)
        {
            this.str = str;
        }
        #endregion

        #region 静态方法
        public static void TestStaticFun()
        {
            Debug.Log("无参静态方法");
        }

        public static int TestStaticFun2(int i)
        {
            Debug.Log("有参静态方法" + i);

            return i + 10;
        }
        #endregion

        #region 成员方法
        public void TestFun()
        {
            Debug.Log("无参无返回值 成员方法调用");
        }

        public int TestFun2(int i)
        {
            Debug.Log("有参有返回值 成员方法调用");
            return 10 + i;
        }
        #endregion

        #region 重载方法
        public void TestFun(int i)
        {
            Debug.Log("重载函数1，传进来的参数是" + i);
        }

        public void TestFun(float f)
        {
            Debug.Log("重载函数2，传进来的参数是" + f);
        }
        #endregion

        #region ref和out方法
        public float TestFun3(int i, ref List<int> list, out float f)
        {
            f = .5f;
            list.Add(5);
            for (int j = 0; j < list.Count; j++)
                Debug.Log(list[j]);

            return i + list.Count + f;
        }
        #endregion

    }
}
```

在Unity工程得到反射类使用成员

我们已在Lesson4_Test创建对象时接触过 `IType` Unity反射创建ILRuntime中的对象。

我们就使用了ILRuntime中的反射相关内容进行对象的创建。

获取ILRuntime对应 `IType` 类型：
```cs
IType iType = ILRuntimeManager.Instance.appDomain.LoadedTypes["HotFix_Project.Lesson4_Test"];
```

通过 `IType` 获取到对应的 `Type`：
```cs
Type type = iType.ReflectionType;
```

通过反射获取各种内容来进行调用：
- 构造函数
```cs
object obj = type.GetConstructor(new Type[0]).Invoke(null);
print(obj); // HotFix_Project.Lesson4_Test
```
- 成员变量
```cs
var testIInfo = type.GetField("TestInt");
print(testIInfo.GetValue(obj)); // 0
```
- 成员属性
```cs
var strInfo = type.GetProperty("Str");
strInfo.SetValue(obj, "897654");
print(strInfo.GetValue(obj)); // 897654
```
- 成员方法
```cs
var methodInfo = type.GetMethod("TestFun", new Type[0]);
methodInfo.Invoke(obj, null); // 无参无返回值 成员方法调用
```

注意：
在Unity中反射使用ILRuntime热更工程中类时，我们不能够使用 `Activator.CreateInstance(type)` 的形式去创建对象，这样会报错。想要在主工程中创建ILRuntime热更工程中的对象，必须使用我们之前间接过的三种方式。

![[对象生成]]

## 总结
Unity中反射使用ILRuntimeILRuntime热更工程中内容：
1. `IType type = appdomain.LoadedTypes["TypeName"]; Type t = type.ReflectedType;`
2. 不能使用 `Activator.CreateInstance` 或 `new T()` 创建实例，只能通过Lesson3中的反射方式创建：`appdomain.Instantiate` 或者 `type.GetConstructor` 后 `Invoke`。
### 原因
1. **类型系统不同**
    - ILRuntime 中的类型并不是原生的 `System.Type`，而是通过 `ILRuntime` 自己的类型系统（如 `IType`）来管理。因此，`Activator.CreateInstance` 和 `new T()` 这些方法无法直接识别 ILRuntime 中的类型。
    - 在 Unity 主工程中，无法通过 `Type.GetType` 获取热更 DLL 中的类型，而必须通过 ILRuntime 的 `AppDomain` 来获取。
        
2. **CLR 重定向限制**
    - ILRuntime 提供了 CLR 重定向机制来解决部分反射调用问题，但 `Activator.CreateInstance` 和 `new T()` 的直接使用仍然受限。这些方法内部的实现逻辑与 ILRuntime 的运行时类型系统不兼容。

ILRuntimeILRuntime热更工程中使用反射，和C#中使用反射一样。