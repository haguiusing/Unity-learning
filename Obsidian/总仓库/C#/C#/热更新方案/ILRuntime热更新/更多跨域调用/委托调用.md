主入口：![[ILRuntimeMain.cs]]
![[Lesson10.cs]]

### 在Unity中申明自定义委托后使用
1.ILRuntime中委托成员 关联ILRuntime工程中函数
直接常规使用即可
不会出现报错

2.Unity中委托成员 关联ILRuntime工程中函数
![[Pasted image 20250603143705.png]]
直接关联会出现报错，这里就涉及到委托成员的跨域
相当于Unity中的委托成员中存储了ILRuntime工程中的函数
就存在了跨域调用

我们需要进行以下处理：
可以通过报错信息中的提示
在进行初始化时进行代码的添加
主要有两部分：
1.注册委托(主要目的，避免IL2CPP打包裁剪报错)
2.注册委托转换器（主要目的，ILRuntime内部所有的委托都是以Action或Fun来存储的）

在InitILRuntime()方法注册委托转换器
![[ILRuntimeMgr 1.cs|]]
![[Pasted image 20250603144205.png]]
有参有返回值时还需注册委托


注意：
1.委托的注册相关流程必须在主工程中完成，在ILRuntime中没用
2.为了避免添加自定义委托转换器
  我们在使用委托时 尽量使用System命名空间中的
  Action和Fun
  这样就不需要进行注册委托转换器了，只需要注册即可

### 在ILRuntime中申明自定义委托后使用
1.ILRuntime中委托成员 关联ILRuntime工程中函数

2.Unity中委托成员 关联ILRuntime工程中函数
一般不会出现基础工程中
使用还无法预知的可变代码
所以我们不需要考虑这种情况

### 总结
在委托的跨域调用中
如果出现Unity中自定义委托跨域关联ILRuntime中函数
需要进行
	1.注册委托(主要目的，避免IL2CPP打包裁剪报错)
	2.注册委托转换器（主要目的，ILRuntime内部所有的委托都是以Action或Fun来存储的）
注意：
	1.委托的注册相关流程必须在主工程中完成
	2.为了避免添加自定义委托转换器
	我们在使用委托时 尽量使用System命名空间中的
  Action和Fun
  这样就不需要进行注册委托转换器了，只需要注册即可
