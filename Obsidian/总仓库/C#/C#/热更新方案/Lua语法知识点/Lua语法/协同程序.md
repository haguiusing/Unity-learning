[协同程序](file:///D:/Unity%20Lua/Lua%E8%AF%AD%E6%B3%95/Lua%E8%AF%AD%E6%B3%95/Lesson13_Coroutine.lua   )

--thread（线程）
--在 Lua 里，最主要的线程是协同程序（coroutine）。
--它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，
--可以跟其他协同程序共享全局变量和其他大部分东西。

--线程跟协程的区别：
--<font color="#ffc000">线程可以同时多个运行，而协程任意时刻只能运行一个</font>，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。

| 方法                  | 描述                                                                                   |
| ------------------- | ------------------------------------------------------------------------------------ |
| coroutine.create()  | 创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用                          |
| coroutine.resume()  | 重启 coroutine，和 create 配合使用<br>默认第一个返回值 是 协程是否启动成功；第二个返回值 是 yield里面的返回值               |
| coroutine.yield()   | 挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果                            |
| coroutine.status()  | 查看 coroutine 的状态  <br>注：coroutine 的状态有三种：dead，suspended，running，具体什么时候有这样的状态请参考下面的程序 |
| coroutine.wrap()    | 创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复                            |
| coroutine.running() | 返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 coroutine 的线程号             |
## 协程的创建
--常用方式
--coroutine.create(方法)
--写法1
```lua
fun = function()
	print(123)
end
co = coroutine.create(fun) 
```
--写法2
```lua
co = coroutine.create(function() 
	print(123)
end)
```

协程的本质是一个线程对象  --thread

## 协程的运行
```lua
--第一种方式 对应的 是通过 create创建的协程
coroutine.resume(co)
--第二种方式 对应的 是通过 wrap创建的协程
co2()
```

## 协程的挂起
coroutine.yield(coroutine[, val1, ···]) 任何传入 yield 的参数都会作为之前 resume 的调用结果返回。
coroutine.isyieldable(co)
```lua
fun2 = function()
	local i = 1
	while true do
		print(i)
		i = i + 1
		--协程的挂起函数
		print(coroutine.status(co3))
		print(coroutine.running())
		coroutine.yield(i)  --挂起 coroutine，将 coroutine 设置为挂起状态 等待下一个resume
	end
end

co3 = coroutine.create(fun2)
--默认第一个返回值 是 协程是否启动成功
--第二个返回值 是 yield里面的返回值
isOk, tempI = coroutine.resume(co3)  --1 running thread: 00A21D68
print(isOk,tempI)  --true	2
isOk, tempI = coroutine.resume(co3)  --2 running thread: 00A21D68
print(isOk,tempI)  --true	3
isOk, tempI = coroutine.resume(co3)  --3 running thread: 00A21D68
print(isOk,tempI)  --true	4

co4 = coroutine.wrap(fun2)
--这种方式的协程调用 也可以有返回值 
--只是没有默认第一个返回值来协程是否启动成功
print("返回值 "..co4())
print("返回值 "..co4())
print("返回值 "..co4())
```

## 协程的状态
--coroutine.status(协程对象)
--dead 结束
--suspended 暂停
--running 进行中
print(coroutine.status(co3))
print(coroutine.status(co))

--这个函数可以得到当前正在 运行的协程的线程号
print(coroutine.running())

coroutine.running就可以看出来,coroutine在底层实现就是一个线程。
当create一个coroutine的时候就是在新线程中注册了一个事件。

当使用resume触发事件的时候，create的coroutine函数就被执行了，当遇到yield的时候就代表挂起当前线程，等候再次resume触发事件。