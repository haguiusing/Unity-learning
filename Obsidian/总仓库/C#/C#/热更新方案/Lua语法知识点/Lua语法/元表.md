[元表](file:///D:/Unity%20Lua/Lua%E8%AF%AD%E6%B3%95/Lua%E8%AF%AD%E6%B3%95/Lesson14_Metatable.lua)

在 Lua table 中我们可以访问对应的 key 来得到 value 值，但是却无法对两个 table 进行操作(比如相加)。

元表是用来定义对table或userdata操作方式的表
## 举个例子
```lua
local t1 = {1}
local t2 = {2}
local t3 = t1 + t2
```
我们直接对两个table执行＋运算，会报错

```lua
lua: /usercode/file.lua:3: attempt to perform arithmetic on local 't1' (a table value)
```
因为程序不知道如何对两个表执行+运行，这时候就需要通过元表来定义如何执行t1的+运算，有点类似于c语言中的运算符重载。

因此 Lua 提供了元表(Metatable)，允许我们改变 table 的行为，每个行为关联了对应的元方法。
## 元表概念
--任何表变量都可以作为另一个表变量的元表
--任何表变量都可以有自己的元表（爸爸）
--当我们子表中进行一些特定操作时
--会执行元表中的内容

## 设置元表
- **setmetatable(table,metatable):** 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。
- **getmetatable(table):** 返回对象的元表(metatable)。
```lua
meta = {}
myTable = {}
--设置元表函数
--第一个参数 子表
--第二个参数 元表（爸爸）
setmetatable(myTable, meta)  -- 把 meta 设为 mytable 的元表
getmetatable(myTable)  --table: 009F10A0
```

## 元方法
### \_\_index 元方法
<font color="#ffff00">控制元表的读取操作</font>
- 当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__index 键。
- 如果__index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。

### \_\_newindex 元方法
<font color="#ffff00">控制元表的写入操作</font>
<font color="#ffff00">newIndex 当赋值时，如果赋值一个不存在的索引，那么会把这个值赋值到newindex所指的表中 不会修改自己</font>
```lua
meta7 = {}
meta8 = {}
meta7.__newindex = meta8
myTable7 = {}
setmetatable(myTable7, meta7)
myTable7.age = 7
print(myTable7.age)  --nil
print(meta8.age)  --7
--rawset 该方法 会忽略newindex的设置 只会该自己的变量
rawset(myTable7, "age", 2)
print(myTable7.age)   --2
```

--__index与查找有关
--__newIndex与申明变量有关
--两者都是先查子表，再看元表，再查元表索引

#### rawget 和 rawset
有时候我们希望直接改动或获取表中的值时，就需要rawget和rawset方法了。  
**rawget可以让你直接获取到表中索引的实际值，而不通过元表的__index元方法。**
```lua
local mt = {}
mt.__index = {key = "it is key"}
t = {}
setmetatable(t,mt)
print(t.key)
--通过rawget直接获取t中的key索引
print(rawget(t,"key"))
```

结果：
```lua
it is key
nil
```

**rawset可以让你直接为表中索引的赋值，而不通过元表的__newindex元方法。**
```lua
local mt = {}
local newTable = {}
mt.__newindex = newTable
t = {}
setmetatable(t,mt)
print(t.newKey,newTable.newKey)
--通过rawset直接向t的newKey索引赋值
rawset(t,"newKey","it is newKey")
print(t.newKey,newTable.newKey)
```

结果：
```lua
nil	nil
it is newKey	nil
```
<font color="#ffff00">rawset</font> 该方法 会忽略__newindex的设置 只会该自己的变量
<font color="#ffff00">rawget</font> 方法忽略__index

### \_\_call 元方法
<font color="#ffff00">当子表被当做一个函数来使用时 会默认调用这个__call中的内容</font>

__call 元方法在 Lua 调用一个值时调用。以下实例演示了计算表中元素的和：
```lua
-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用  
-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数  
function table_maxn(t)  
    local mn = 0  
    for k, v in pairs(t) do  
        if mn < k then  
            mn = k  
        end  
    end  
    return mn  
end  
  
-- 定义元方法__call  
mytable = setmetatable({10}, {  
--当希望传参数时 一定要记住 默认第一个参数 是调用者自己
  __call = function(mytable, newtable)  
        sum = 0  
        for i = 1, table_maxn(mytable) do  
                sum = sum + mytable[i]  
        end  
    for i = 1, table_maxn(newtable) do  
                sum = sum + newtable[i]  
        end  
        return sum  
  end  
})  
newtable = {10,20,30}  
print(mytable(newtable))   --
```

以上实例执行输出结果为：
70
### \_\_tostring 元方法
<font color="#ffff00">当子表要被当做字符串使用时 会默认调用这个元表中的tostring方法</font>

用于修改表的输出行为。以下实例我们自定义了表的输出内容：
```lua
mytable = setmetatable({ 10, 20, 30 }, {  
  __tostring = function(mytable)  
    sum = 0  
    for k, v in pairs(mytable) do  
                sum = sum + v  
        end  
    return "表所有元素的和为 " .. sum  
  end  
})  
print(mytable)  
```

以上实例执行输出结果为：
表所有元素的和为 60

### 运算符重载
| 模式       | 描述           |
| -------- | ------------ |
| __add    | 对应的运算符 '+'.  |
| __sub    | 对应的运算符 '-'.  |
| __mul    | 对应的运算符 '*'.  |
| __div    | 对应的运算符 '/'.  |
| __mod    | 对应的运算符 '%'.  |
| __unm    | 对应的运算符 '-'.  |
| __concat | 对应的运算符 '..'. |
| __eq     | 对应的运算符 '=='. |
| __lt     | 对应的运算符 '<'.  |
| __le     | 对应的运算符 '<='. |
```lua
meta4 = {
	--相当于运算符重载 当子表使用+运算符时 会调用该方法
	--运算符+
	__add = function(t1, t2)
		return '加法：' .. t1.age + t2.age
	end,

	--运算符-
	__sub = function(t1, t2)
		return '减法：' .. t1.age - t2.age
	end,

	--运算符*
	__mul = function(t1, t2)
		return '乘法：' .. t1.age * t2.age
	end,

	--运算符/
	__div = function(t1, t2)
		return '除法：' .. t1.age / t2.age
	end,

	--运算符%
	__mod = function(t1, t2)
		return '取余：' .. t1.age % t2.age
	end,

	--运算符^
	__pow = function(t1, t2)
		return '幂运算：' .. t1.age ^ t2.age
	end,

	--运算符==
	__eq = function(t1, t2)
		return t1.age == t2.age
	end,

	--运算符<
	__lt = function(t1, t2)
		return t1.age < t2.age
	end,

	--运算符<=
	__le = function(t1, t2)
		return t1.age <= t2.age
	end,

	--运算符..
	__concat = function(t1, t2)
		return t1.age .. t2.age
	end

	--运算符- 正负取反、无效
	--__unm = function (t1,t2)
	--	local x = -t1
	--	local y = -t2
	--	return x,y
	--end

}
myTable4 = {age = 1}
setmetatable(myTable4, meta4)
myTable5 = {age = 2}
setmetatable(myTable5, meta4)

print("**普通运算符**")
print(myTable4 + myTable5)
print(myTable4 - myTable5)
print(myTable4 * myTable5)
print(myTable4 / myTable5)
print(myTable4 % myTable5)
print(myTable4 ^ myTable5)

print("**条件运算符**")
--如果要用条件运算符 来比较两个对象
--这两个对象的元表一定要一致 才能准确调用方法
print(myTable4 == myTable5)
print(myTable4 < myTable5)
print(myTable4 > myTable5)
print(myTable4 <= myTable5)

print(myTable4 .. myTable5)
--print(myTable4 - myTable5)
```

### 其他
\_\_gc（参见[2.5.3](https://atom-l.github.io/lua5.4-manual-zh/2.5.3.html)），\_\_close（参见[3.3.8](https://atom-l.github.io/lua5.4-manual-zh/3.3.8.html)），\_\_mode（参见[2.5.4](https://atom-l.github.io/lua5.4-manual-zh/2.5.4.html)），以及__name。（[tostring](https://atom-l.github.io/lua5.4-manual-zh/2.4.html#tostring-v)和错误消息中可能会用到包含字符串的__name。）

## 元表的使用场景
### 作为table的元表
通过为table设置元表可以在lua中实现面向对象编程。

### 作为userdata的元表
通过对userdata和元表可以实现在lua中对c中的结构进行面向对象式的访问。