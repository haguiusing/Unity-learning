[unity 游戏优化篇 - 知乎](https://www.zhihu.com/column/c_1772663087109160961)
[unity——UI优化策略合集 - 知乎](https://zhuanlan.zhihu.com/p/617758209#:~:text=10%E3%80%81UI%E8%B4%B4%E5%9B%BE%E8%AE%BE%E7%BD%AE%E7%9A%84%E4%BC%98%E5%8C%96%201%20%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81Alpha%E9%80%9A%E9%81%93%E3%80%82%20%E9%9C%80%E8%A6%81%E5%88%99%E6%89%93%E5%BC%80%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%99%E5%85%B3%E9%97%AD%E3%80%82%202%20%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C2%E6%AC%A1%E6%96%B9%E5%A4%A7%E5%B0%8F%E4%BF%AE%E6%AD%A3%E3%80%82%20%E5%AF%B9%E4%BA%8EUI%E8%B4%B4%E5%9B%BE%E6%9D%A5%E5%A4%B4%E5%83%8F%E8%BF%99%E7%B1%BBIcon%E5%9F%BA%E6%9C%AC%E4%B8%8A%E9%83%BD%E6%98%AF2%E6%AC%A1%E6%96%B9%E5%A4%A7%E5%B0%8F%E3%80%82%203,4%20%E5%8E%BB%E9%99%A4Mipmap%E3%80%82%20Mipmap%E6%98%AF%E5%AF%B93D%E8%BF%9C%E8%BF%91%E8%A7%86%E8%A7%89%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%8C%E9%80%9A%E8%BF%87%E7%94%9F%E6%88%90%E4%B8%8D%E5%90%8C%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%9B%BE%EF%BC%8C%E5%9C%A8%E6%91%84%E5%83%8F%E5%A4%B4%E8%BF%9C%E7%A6%BB%E7%89%A9%E4%BD%93%E6%97%B6%E5%9B%A0%E4%B8%BA%E4%B8%8D%E9%9C%80%E8%A6%81%E9%AB%98%E6%B8%85%E7%9A%84%E5%9B%BE%E7%89%87%E8%80%8C%E4%BD%BF%E7%94%A8Mipmap%E7%94%9F%E6%88%90%E7%9A%84%E5%B0%8F%E8%80%8C%E6%A8%A1%E7%B3%8A%E7%9A%84%E8%B4%B4%E5%9B%BE%EF%BC%8C%E4%BB%8E%E8%80%8C%E5%87%8F%E8%BD%BBGPU%E7%9A%84%E8%B4%9F%E6%8B%85%E3%80%82%20%E4%BD%862D%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%BF%9C%E8%BF%91%E4%B9%8B%E5%88%86%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E8%BF%99%E4%B8%AA%E5%8A%9F%E8%83%BD%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AF%9D%E5%8F%8D%E8%80%8C%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E5%92%8C%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%8A%A0%E5%A4%A7%EF%BC%8CUI%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%A8%A1%E7%B3%8A%E3%80%82%205%20%E9%80%89%E6%8B%A9%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F%E3%80%82%20%E5%8E%8B%E7%BC%A9%E4%B8%BB%E8%A6%81%E6%97%B6%E4%B8%BA%E4%BA%86%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E7%9A%84%E6%B6%88%E8%80%97%E3%80%81%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E6%B6%88%E8%80%97%EF%BC%8C%E9%99%8D%E4%BD%8ECPU%E4%B8%8EGPU%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B8%A6%E5%AE%BD%E6%B6%88%E8%80%97%EF%BC%8C%E5%9C%A8%E4%BF%9D%E8%AF%81%E6%B8%85%E6%99%B0%E5%BA%A6%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%EF%BC%8C%E5%BA%94%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F%E6%9D%A5%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98%E5%92%8C%E5%8C%85%E4%BD%93%E3%80%82%20%E4%B8%8B%E9%9D%A2%E8%BF%99%E4%BA%9B%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F%E5%8E%8B%E7%BC%A9%E5%8A%9B%E5%BA%A6%E9%80%90%E7%BA%A7%E5%A2%9E%E5%A4%A7%EF%BC%9A)
# 1. 什么是DrawCall？DrawCall高了又什么影响？如何降低DrawCall？
CPU调用图像编程接口。  
在[Shader](https://so.csdn.net/so/search?q=Shader&spm=1001.2101.3001.7020)渲染流水线的应用阶段，当CPU准备好场景数据，设置好渲染状态，就会调用DrawCall命令，开启一个渲染过程。
Unity中，CPU准备好需要绘制的元素，对底层图形程序接口进行调用的过程，每次引擎准备数据并通知GPU的过程称为一次Draw Call。DrawCall越高对显卡的消耗就越大。
降低DrawCall的方法：
动态合批
静态合批
降低shader的等级特性
场景优化策略——遮挡技术。
rectMask2D替代Mask

# 2. UI优化小知识
- UI动静分离
以canvas为节点，设置动态canvas和静态canvas，实际项目静态元素较多，动态元素较少，动静分离后，CPU在重绘和合并时消耗就会减少。
- 拆分过重的UI
将界面中隐藏的独立界面做一次拆分
对二次显示内容，如部分动效图标，小窗口等做二次拆分。如果小个体频繁加载和销毁，也同样会消耗过多CPU，便可以采用UI预加载。
- UI预加载
UI预设体实例化到场景中的过程：网格合并，组件初始化，渲染初始化，图片加载，界面逻辑调用等，消耗大量CPU
预加载：把资源加载到内存、UI实例化和UI初始化的CPU消耗放在loading等待时间线上
如何进行UI预加载？
[UI(七) - UI优化(一)_系统ui逐步优化-CSDN博客](https://blog.csdn.net/s178435865/article/details/129534506)
- UI图集Alpha分离
 [UI(七) - UI优化(二)_为什么ui图集alpha分离-CSDN博客](https://blog.csdn.net/s178435865/article/details/129535213)
 使用压缩模式ECT或PVRTC时将透明通道也一并压缩进去了，导致了渲染的扭曲
主要是针对NGUI方案，Unity内部已经完成了Alpha分离
首先：TexturePacker打图集时候，改成打一张RGB888的PNG图和一张Alpha8的PNG图
其次：修改NGUI的原始着色器，绑定主图和绑定Alpha图
然后：将NGUI的着色器shader中相应修改为新的颜色通道和透明通道
最后：NGUI工具类也要相应修改编辑几个类
最终：主图和Alpha图合成新图片替换原来的图片
- UI字体拆分
提取常用字体
使用TMP，同样会生成纹理和图集，相比TEXT优势是，TMP是矢量
字算法，MESH顶点数少，字体同源，各语言能同屏显示。
- ScrollView优化
不停滚动会导致合批网格重构、渲染裁剪

使用对象池进行优化
- 网格重构优化
UGUI的Mesh的合并机制是拥有相同的材质球的Mesh合并在一起才能达到最佳效果，一个材质球对应一个图集，只有相同图集内的图片才需要合并在一起。
UGUI中当元素需要对颜色进行改变时，UGUI是通过改变顶点的颜色来实现颜色的变化的。改变当前元素的顶点颜色，然后需要将它们重新合并到整块的Mesh里去，因为不能直接从原来合并好的Mesh上找到当前的顶点位置，所以需要一次整体的合并重构Mesh。
建一个材质球，提前告诉UGUI：我们使用自己的特殊的材质球进行渲染。当颜色动画对颜色和 alpha 更改时，我们直接对我们自定义的材质球进行颜色和 alpha 的改变。这样UGUI就不需要重构Mesh了，因为把渲染的工作交给了新的材质球，而不是通过 UGUI 设置顶点颜色和新材质球来达到效果。
- UI展示与关闭优化
- 对象池运用
当程序中有重复实例化兵不断摧毁的对象时需要使用对象池进行优化
每个需要使用对象池的对象都需要继承对象池的基类对象
销毁操作是通过对象池接口提供的回收接口
场景结束时要及时销毁整个对象池
- UI贴图设置优化

- 高低端机型画质优化
使用两套UI贴图，高清，低清，两套图，两套Prefab，NGUI和UGUI高清HD和SD切换的流程可以通过编写脚本程序一键搞定。
模型和特效使用不同质量（三角面数）的预制体，预制体命名后缀做加载区分，区分等级
阴影根据使用情况进行区分
整体贴图渲染质量进行区别对待
使用QuailtySetting的API来对阴影和贴图渲染质量做操作
通过程序来区分机型，ios通过机型就能判断UnityEngine.IOS.Device.generation== XXXX.Iphone6；安卓通过CPU型号，内存大小，系统，平均帧率等进行综合判断
- UI图集拼接优化
充分利用图集空间
图集大小控制1024*1024
图片的拼接归类

# 3. 层消隐距离技术
如果场景中存在大量小"物件”，则可以使用"层消隐距离"来优化场景;"层消隐距离"就是在比较远的距离将小物体剔除以减少绘图调用的数量（比如:可以一个大型场景中，高大型的物体任然可见，但是一些小装饰内容(小狗、车子之类的则可以隐藏）)

# 4. LOD是什么，优缺点是什么?
LOD(Level of detail)多层次细节，是最常用的游 戏优化技术。  
它按照模型的位置和重要程度决定 物体渲染的资源分配，降低非重要物体的面数和 细节度，从而获得高效率的渲染运算。

这就是说，根据摄像机与模型的距离，来决定显示哪一个模型，一般距离近的时候显示高精度多细节模型，距离远的时候显示低精度低细节模型，来加快整体场景的渲染速度。
- 作用 : 优化GPU
- 缺点 : 同一模型要准备多个模型，消耗内存。
- 特点 : 以内存做消耗来优化GPU

# 5. 合批
一次Draw Call中[批量处理](https://so.csdn.net/so/search?q=%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020)多个物体。只要物体的变换和材质引用相同，GPU就可以按完全相同的方式进行处理，即可以把它们放在一个Draw Call中。

注意：简单来说在一个Canvas下，需要相同的材质，相同的[纹理](https://so.csdn.net/so/search?q=%E7%BA%B9%E7%90%86&spm=1001.2101.3001.7020)以及相同的Z值。  
例如Ul上的字体Texture使用的是字体的图集，往往和我们自己的UI图集不一样，因此无法合批。还有UI的动态更新会影响网格的重绘，因此需要动静分离。

# 6.静态合批
将static的静态物体（永远不会移动、旋转和缩放） ，如果相同材质球，面数在一定范围之内。unity会自动合并成一个batch送往GPU处理。

**原理**：在开始阶段把需要静态批处理的GameObject进行一次网格合并操作，然后把这个合并之后的大网格保存起来，后续都是用这个网格而不需要再进行合并。  
在预处理阶段，把一些材质相同的模型的顶点统一变换到世界空间坐标下，并且新构建一个大的VB把数据保存下来，在绘制时，就会把这个大的VB提交上去，只需要设置一次渲染状态，再进行多次drawcall绘画出每个子模型。 所以Static Batching是不会减少drawcall的，但由于只修改了一次渲染状态依然可以减少CPU的消耗。而且在渲染前，也可以进行视锥体剔除，减少顶点着色器对不可见的顶点的处理次数，提交GPU的效率。

**操作方法**：把要进行静态批处理的GameObject在Inspector面板右上角的Static勾选(实际上只需要勾选Batching Static即可)
- **优点**：因为只需要进行一次，所以性能会比动态批处理要好。
- **缺点**： 使用静态合批需要额外的内存开销来存储合并后的几何数据。  
    因为需要额外维护多一份数据，所以包体会变大，占用的内存也会变多（不能有超级大量的相同模型（如：森林里的树））

# 7.动态合批
如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要进行额外的操作。

原理：Unity会检测哪些GameObject使用了同一个共享材质，然后去合并这些使用了同一个共享材质的网格顶点数据，形成一个新的大网格，然后传给显存，直接渲染这个大网格就相当于渲染了所有的被合并的小网格，而这只需要一次DrawCall。
在每一帧运行时，计算相同材质的模型，把他合并批次进行渲染。动态合批只需要设置一次渲染状态，且能减少drawcall次数。

优点： 不用自己做任何事情，Unity会在游戏中自动进行动态批处理，只要满足下述条件。

顶点属性要小于900。例如，如果shader中需要使用顶点位置、法线和纹理坐标这三个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300。因此，优化策略就是shader的优化，少使用顶点属性，或者模型顶点数要尽可能少。（这个是《UnityShader入门精要》这本书上说到的，同时书上也说了不一定是900，可能不同版本的Unity会有所区别，这个可以自己在Unity中去手动验证得出）
多Pass的shader会中断批处理。
使用LightingMap的物体需要小心处理。为了让这些物体可以被动态批处理，需要保证它们指向LightingMap中的同一位置。

# 8. 动态合批跟静态合批的区别
动态批处理一切都是自动的，不需要做任何操 作，而且物体是可以移动的，但是限制很多。
静态批 处理自由度很高，限制很少，缺点可能会占用更多 的内存，而且经过静态批处理后的所有物体都不可以 再移动了。
静态合批发生在加载场景的时候。
动态合批发生在游戏运行的时候。

# 9. 如何优化内存?
有很多种方式，例如

压缩自带类库;
将暂时不用的以后还需要使用的物体隐藏起来而不 是直接Destroy掉;
释放AssetBundle占用的资源;
降低模型的片面数，降低模型的⻣骼数量，降低贴 图的大小;
使用光照贴图，使用多层次细节(LOD)，使用着色 器(Shader)，使用预设(Prefab)。

# 10. mask和rectmask2d的区别
Mask使用模板缓冲来实现区域切除逻辑（Stencil），会占用两个DC。它实现最初设置模板缓存会给Mask添加一个特殊的材质，并且以像素为单位存储是否需要显示最后还原模板缓存，这两次操作各增加一次DC。它可以和其他Mask子物体进行合批，如果两个mask重叠了，那就不能进行合批，会产生额外的dc。

rectmask2d继承自IClipper接口，内部主要实现的就是一个方法来实现了区域的切除逻辑，本身是不占用DC的，完全遮住的情况下不会绘制顶点和面，不参与深度运算不占用DC（和mask的最大区别）。 缺点：它无法和RectMask的子物体进行合批，只能和自身的子物体进行合批（注：如果本身带了Image组件的话是可以进行合批的）

mask2d只能矩形，要不同形状的遮罩还是得mask，所以RectMask2D并不一定完全好，他在特定情况下无法合批。

# 11. 贴图透明通道分离，压缩格式设为ETC/PVRTC
最初我们使用了DXT5作为贴图压缩格式，希望能减小贴图的内存占用，但很快发现移动平台的显卡是不支持的。因此对于一张1024x1024大小的RGBA32贴图，虽然DXT5可将它从4MB压缩到1MB，但系统将它送进显卡之前，会先用CPU在内存里将它解压成4MB的RGBA32格式（软件解压），然后再将这4MB送进显存。于是在这段时间里，这张贴图就占用了5MB内存和4MB显存；而移动平台往往没有独立显存，需要从内存里抠一块作为显存，于是原以为只占1MB内存的贴图实际却占了9MB！

所有不支持硬件解压的压缩格式都有这个问题。经过一番调研，我们发现安卓上硬件支持最广泛的格式是ETC，苹果上则是PVRTC。但这两种格式都是不带透明（Alpha）通道的。因此我们将每张原始贴图的透明通道都分离了出来，写进另一张贴图的红色通道里。这两张贴图都采用ETC/PVRTC压缩。渲染的时候，将两张贴图都送进显存。同时我们修改了NGUI的shader，在渲染时将第二张贴图的红色通道写到第一张贴图的透明通道里，恢复原来的颜色：
```  
fixed4 frag (v2f i) : COLOR  
 
    fixed4 col;  
 
    col.rgb = tex2D(_MainTex, i.texcoord).rgb;  
 
    col.a = tex2D(_AlphaTex, i.texcoord).r;  
 
    return col * i.color;  
 
fixed4 frag (v2f i) : COLOR
 
{
 
    fixed4 col;
 
    col.rgb = tex2D(_MainTex, i.texcoord).rgb;
 
    col.a = tex2D(_AlphaTex, i.texcoord).r;
 
    return col * i.color;
 
}

```

# 12. 关闭贴图的读写选项
Unity中导入的每张贴图都有一个启用可读可写（Read/Write Enabled）的开关，对应的程序参数是TextureImporter.isReadable。
选中贴图后可在Import Setting选项卡中看到这个开关。只有打开这个开关，才可以对贴图使用Texture2D.GetPixel，读取或改写贴图资源的像素，但这就需要系统在内存里保留一份贴图的拷贝，以供CPU访问。
一般游戏运行时不会有这样的需求，因此我们对所有贴图都关闭了这个开关，只在编辑中做贴图导入后处理（比如对原始贴图分离透明通道）时打开它。
这样，上文提到的1024x1024大小的贴图，其运行时的2MB内存占用又可以少一半，减小到1MB。


# 13. Unity 在移动设备上的⼀些优化资源的方法
1. 使⽤assetbundle，实现资源分离和共享，将内存控
2. 制到200m之内，同时也可以实现资源的在线更新
3. 顶点数对渲染⽆论是cpu还是gpu都是压⼒最⼤的贡
4. 献者，降低顶点数到8万以下，fps稳定到了30帧左右
5. 只使⽤⼀盏动态光，不是⽤阴影，不使⽤光照探头
6. 粒⼦系统是cpu上的⼤头
7. 剪裁粒⼦系统
8. 合并同时出现的粒⼦系统
9. ⾃⼰实现轻量级的粒⼦系统
10. animator也是⼀个效率奇差的地⽅
11. 把不需要跟⻣骼动画和动作过渡的地⽅全部使⽤
12. animation，控制⻣骼数ᰁ在30根以下
13. animator出视ᰀ不更新
14. 删除⽆意义的animator
15. animator的初始化很耗时（粒⼦上能不能尽ᰁ不⽤
16. animator）
17. 除主⻆外都不要跟⻣骼运动apply root motion
18. 绝对禁⽌掉那些不带刚体带包围盒的物体（static
19. collider ）运动
20. NUGI的代码效率很差，基本上runtime的时候对cpu的
21. 贡献和render不相上下
22. 每帧递归的计算finalalpha改为只有初始化和变动时
23. 计算
24. 去掉法线计算
25. 不要每帧计算viewsize 和windowsize
26. filldrawcall时构建顶点缓存使⽤array.copy
27. 代码剪裁：使⽤strip level ，使⽤.net2.0 subset
28. 尽量减少smooth group
29. 给美术定⼀个严格的经过科学验证的美术标准，并在U3D⾥⾯配以相应的检查⼯具
![[Pasted image 20250416171608.png]]
![[Pasted image 20250416171621.png]]
# 14. CPU端性能优化小知识点
- 逻辑和表现尽可能分离开，这样逻辑层的更新频率可以适当降低些.
- 对于一些热点函数，如mmo的实体更新、实例化，使用分帧处理，分摊单帧时间消耗.
- 做好同屏实体数量、特效数量、距离显隐等优化.
- 完善日志输出，避免没必要的日志输出，同时警惕日志字符串拼接.
- 使用骨骼烘焙 + GPUSkinning + Instance 降低CPU蒙皮骨骼消耗和drawcall.
- 开启模型的Optimize GameObjects减少节点数量和蒙皮更新消耗.
- UI拼预制做好动静分离，对于像血条名字这种频繁变动的ui，做好适当的分组.
- 减少C#和lua的频繁交互，尽量精简两者传递的参数结构.
- 使用stringbuilder优化字符串拼接的gc问题.
- 删除非必要的脚本功能函数，特别是Update/LateUpdate类高频执行函数，因为会产生C++到C#层的调用开销. 对于Update里需要用到的组件、节点等提前Cache好.
- 场景里频繁使用的资源或数据结构做好资源复用和对象池.
- 对于频繁显示隐藏的UI，可以先移出到屏幕外，如果长时间不显示再进行Deactive.
- 合理拆分UI图集，区分共用图集和非共用图集，共用图集可以常驻内存，非共用图集优先按功能分类,避免资源冗余.
- 使用IL2CPP, 编译成C++版本能极大的提升整体性能.
- 避免直接使用Material.Setxxx/Getxxx 等调用，这些调用会触发材质实例化消耗，可以考虑使用 SharedMaterial / MaterialPropertyBlock代替.
- 合并Shader里的Uniform变量.

# 15. GPU端性能优化小知识点
- 合理规划好渲染顺序，避免不必要的overdraw，如:地形（容易被其他物件遮挡）、天空盒放到较后渲染.
- 分辨率缩放,对于填充率出现瓶颈时，这个是最简单高效的.
- 避免使用GrabPass抓屏，不是所有硬件都支持，加之数据回拷和没法控制分辨率性能很差，可考虑使用CommandBuffer.blit去优化.
- 控制好地形的Blend层数，控制在4层以内，考虑到地形一般屏占面积大、贴图采样次数多，对于中低画质考虑不用normalmap.
- 做好物件、树、角色的LOD.
- 避免使用RenderWithShader类方式来定制DepthTexture,可以考虑Camera的 public void SetTargetBuffers(RenderBuffer colorBuffer, RenderBuffer depthBuffer);进行优化.
- 检查Shader的VertexInput 和 VertexOutput是否存在冗余数据.如:顶点色、多套UV.
- 警惕项目里非必要的双面材质，对于需要局部双面的地方通过加面解决.
- Shader里使用fixed、half代替float，理论上除position、uv、一些涉及depth相关计算使用float外，其他都应该使用fixed（主要是颜色值）、half.
- 对于角色皮肤这种不是特别明显的效果，考虑使用预积分这种低成本的方案.
- 对于frag里的计算过程，如果可以抽出来放到CPU应用层、顶点阶段的优先放这里计算. 需要注意放到顶点阶段引起的平滑过渡问题. 如: eyeVec导致高光过渡问题.
- 镜面反射类效果避免使用反射相机+RT的实现，考虑使用SSR、CubeMap类实现.
- 避免使用实时阴影，如若使用要合理控制下分辨率和阴影距离. 考虑使用Projector.
- 使用统一的后处理框架代替多个Image Effect，可以共用模糊函数，减少blit操作. 另外Unity自带的Postprocessing V2 支持Volume，性能还是不错的.
- Shader里避免使用分支、循环，sin、tan、pow、log等复杂数学运算.
- Unity自带的遮挡剔除因为CPU消耗和内存占用较高，加之不能Instancing，不太适合移动平台，可以考虑静态预计算(缺点是不支持动态物体)、Hi-Z等优化方案.
- 减少alpha test材质的使用，如若使用注意减小面积、控制渲染顺序.

# 16. 内存优化小知识点
- 压缩自带类库;
- 将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉;
- 释放AssetBundle占用的资源;
- 降低模型的片面数，降低模型的骨骼数量，降低贴图的大小;
- 使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。
- 警惕配置表内存占用
- 排查项目冗余的shader
- 减少容器扩容或者利用string字符串拼接等一系列产生GC的操作
- 警惕配置表的内存占用.
- 检查ShaderLab内存占用:
- 避免使用Standard材质，做好相应的variant skip.
- 排查项目冗余的Shader.
- 使用shader_feature替代multi_compile,这样只会收集项目里真正使用的变体组合，避免变体翻倍.
- 检查纹理资源的尺寸、格式、压缩方式、mipmap、Read & Write选项使用是否合理.
- 检查Mesh资源的Read & Write选项、顶点属性使用是否合理.
- 代码级别的检查，如Cache预分配空间、容器的Capacity、GC等.
- 使用Profiler定位下GC，特别是Update类函数里的. 如：字符串拼接、滥用容器等.
- 合理控制RenderTexture的尺寸.
- 优化动画Animation的压缩方式、浮点精度、去除里面的Scale曲线数据.
- 减少场景GameObject节点的数量,最好支持工具监控.

# 17. 简述⼀下对象池，你觉得在FPS里哪些东西适合使用对象池？
对象池就存放需要被反复调⽤资源的⼀个空间，⽐如游戏中要常被大量复制的对象，⼦弹，敌⼈，以及任何重复出现的对象。

# 18. UI图集的作用
图集就是碎图合成大图 降低内存，减少DC。
UI图集有合批没有的优点，就是热更新的时候因为小文件变少了，所以会快一些。
UI图集就是UI的动态合批。
UI图集完成合批的条件：深度 贴图 材质 => 排序好的列表当前这个依次和前面对比是否贴图和材质ID相同决定是否合批。

# 19. 请简述GC（垃圾回收）产生的原因，并描述如何避免？
GC垃圾回收机制，避免堆内存溢出，定期回收那些没有有效引用的对象内存
GC优化，就是优化堆内存，减少堆内存，即时回收堆内存
GC归属于CLR

避免：
- 减少new的次数
- 字符串拼接使用stringbuilder，字符串比较先定义一个变量存储，防止产生无效内存
- list，new时候，规定内存大小
- 如果要射线检测，应该使用避免GC的方法XXXXNoAlloc函数
- foreach迭代器容易导致GC（目前Unity5.5已修复），使用For循环
- 使用静态变量，GC不会回收存在的对象，但静态变量的引用对象可能被回收
- 使用枚举替代字符串变量
- 调用gameobject.tag=="XXX"就会产生内存垃圾；那么采用GameObject.CompareTag()可以避免内存垃圾的产生：
- 不要在频繁调用的函数中反复进行堆内存分配，比如OnTriggerXXX，Update等函数
- 在Update函数中，运行有规律的但不需要每一帧执行的代码，可以使用计时器，比如1秒执行一次某些代码！！！






