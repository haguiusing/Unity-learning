# **C#**
**1. 装箱和拆箱是什么？**
- **装箱（Boxing）**：装箱是一种隐式的类型转换，是指将值类型转换为引用类型（object或接口类型）的操作。例如，将int类型转换为object类型时，会在托管堆上分配内存，并将值类型的数据复制到新分配的内存中，这个过程称为装箱。
    
- **拆箱（Unboxing）**：拆箱是一种显式的类型转换，是指将引用类型（object或接口类型）转换回值类型的操作。例如，将object类型转换回int类型时，需要先确认对象的类型，然后将引用类型中的数据复制到栈上，这个过程称为拆箱。

**2. 值和引用类型在变量赋值时的区别是什么？**
- **值类型**：赋值时会将值类型的数据直接复制到新的变量中。值类型包括结构体、枚举、原始数据类型（如int、float等）等。例如，int a = 5; int b = a; 如果改变a的值，不会影响到b。
    
- **引用类型**：赋值时会将引用类型中的引用（即内存地址）复制到新的变量中，而不是复制实际的数据。引用类型包括类、接口、委托等。例如，object obj1 = new object(); object obj2 = obj1; obj1和obj2指向同一个内存地址，改变其中一个的值会影响另一个。

**3. 委托和事件在使用上的区别是什么？**
- **委托（Delegate）**：委托是一种引用类型，可以指向一个或多个方法。委托可以被实例化，并且可以调用它所指向的方法。在使用委托时，可以直接调用委托实例来执行对应的方法。
    
- **事件（Event）**：事件是基于委托的，是一种特殊的委托。事件通常用于发布/订阅模式，用于在对象之间传递消息。事件的使用受到限制，只能在声明事件的类内部调用事件，而在外部只能订阅或取消订阅事件。

**4. 有两个接口IA和IB，他们中有一个同名方法Test()**
    **一个类同时继承这两个接口，应该如何处理他们的同名方法？**
- 当一个类实现多个接口时，如果这些接口中有同名的方法，可以通过显式接口实现来区分它们。例如：
```csharp
public interface IA
{
    void Test();
}

public interface IB
{
    void Test();
}

public class MyClass : IA, IB
{
    void IA.Test()
    {
        // 实现接口IA的Test方法
    }

    void IB.Test()
    {
        // 实现接口IB的Test方法
    }
}
```
这样，当调用MyClass的实例时，需要显式地指定要调用哪个接口的Test方法。

**5. 请说明C#中的List是如何扩容的**
- 在C#中，`List<T>`内部使用一个数组来存储元素。当添加元素时，如果数组的容量不足，`List<T>`会自动扩容。扩容的策略是：当添加新元素时，如果当前容量已满，`List<T>`会将容量增加到当前容量的两倍（如果当前容量大于0，则新容量为当前容量的两倍；如果当前容量为0，则新容量为4）。扩容过程需要分配新的数组，并将旧数组中的元素复制到新数组中，这会导致一定的性能开销。因此，如果可以预知元素的数量，可以通过设置`List<T>`的初始容量来减少扩容的次数。

# **Unity**
**1. Unity中点乘和叉乘对于我们来说的作用是什么？**
- **点乘（Dot Product）**：点乘可以用来计算两个向量之间的夹角。在Unity中，点乘常用于判断一个物体是否在另一个物体的前方或后方，或者用于计算光照效果中的漫反射。
    
- **叉乘（Cross Product）**：叉乘可以用来计算两个向量的垂直向量。在Unity中，叉乘常用于计算物体的旋转方向，或者用于判断物体的朝向。

**2. Unity中多线程执行下面哪些代码会报错？**
    **A. Application.persistentDataPath**
    **B. File.Exists("文件名")**
    **C. transform.Translate**
    **D. Object.Destroy(对象)**
    
- **A. Application.persistentDataPath**：这个属性可以安全地在多线程中使用，因为它只是获取一个路径字符串。
- **B. File.Exists("文件名")**：这个方法也可以安全地在多线程中使用，因为它只涉及文件系统操作，不会直接影响Unity引擎的状态。
- **C. transform.Translate**：这个方法不能在多线程中使用，因为在Unity中，对Transform的修改必须在主线程中进行，否则会导致未知的错误。
- **D. Object.Destroy(对象)**：这个方法也不能在多线程中使用，因为在Unity中，对象的销毁也必须在主线程中进行。

**3. Application.streamingAssetsPath 和 Application.persistentDataPath**
    **两个路径有何区别？对于我们的意义是什么？**

- **Application.streamingAssetsPath**：这个路径指向的是项目中的StreamingAssets文件夹。在构建后的项目中，这个文件夹中的文件会被原封不动地打包到项目中，并且可以被读取。这个路径在不同平台下有不同的表现，例如在Android平台上，这个路径指向的是APK包内的assets目录。
    
- **Application.persistentDataPath**：这个路径指向的是一个可以读写的目录，用于存储持久化的数据。这个目录在不同平台下也有不同的表现，例如在Android平台上，这个路径指向的是设备的外部存储目录。对于开发者来说，这个路径可以用于存储游戏存档、用户配置等需要长期保存的数据。

**4. 请简述Unity中协程的原理**
- Unity中的协程是一种轻量级的线程，它允许在代码中实现非阻塞的长时间操作。协程通过`StartCoroutine`方法启动，并且在 `IEnumerator`方法中定义。协程的执行是基于帧的，它会在每一帧中执行到`yield return`语句，然后暂停，等待下一帧继续执行。通过使用`yield return new WaitForSeconds(时间)`，可以实现延迟执行；通过使用`yield return null`，可以实现在下一帧继续执行。

**5. Unity底层如何处理C#代码？**
- Unity底层使用Mono或IL2CPP来处理C#代码。在Mono模式下，Unity会将C#代码编译成IL（Intermediate Language）代码，然后由Mono运行时解释执行。在IL2CPP模式下，Unity会将C#代码编译成IL代码，然后将IL代码转换成C++代码，最后编译成原生代码。这样可以提高性能，但会增加构建时间。Unity引擎内部使用C++编写，C#代码与C++代码之间通过插件或API进行交互。