[EventCenter](file://assets/Scripts/ProjectBase/Event/EventCenter.cs)

```cs
namespace My2DDemo
{
    public interface IEventInfo
    {

    }

    public class EventInfo<T> : IEventInfo
    {
        public UnityAction<T> actions;

        public EventInfo(UnityAction<T> action)
        {
            actions += action;
        }
    }

    public class EventInfo : IEventInfo
    {
        public UnityAction actions;

        public EventInfo(UnityAction action)
        {
            actions += action;
        }
    }

    public class EventCenter : BaseManager<EventCenter>
    {
        //key —— 事件的名字（比如：怪物死亡，玩家死亡，通关 等等）
        //value —— 对应的是 监听这个事件 对应的委托函数们
        private Dictionary<string, IEventInfo> eventDic = new Dictionary<string, IEventInfo>();

        /// <summary>
        /// 添加事件监听
        /// </summary>
        /// <param name="name">事件的名字</param>
        /// <param name="action">准备用来处理事件 的委托函数</param>
        public void AddEventListener<T>(string name, UnityAction<T> action)
        {
            //有没有对应的事件监听
            //有的情况
            if (eventDic.ContainsKey(name))
            {
                (eventDic[name] as EventInfo<T>).actions += action;
            }
            //没有的情况
            else
            {
                eventDic.Add(name, new EventInfo<T>(action));
            }
        }

        /// <summary>
        /// 监听不需要参数传递的事件
        /// </summary>
        /// <param name="name"></param>
        /// <param name="action"></param>
        public void AddEventListener(string name, UnityAction action)
        {
            //有没有对应的事件监听
            //有的情况
            if (eventDic.ContainsKey(name))
            {
                (eventDic[name] as EventInfo).actions += action;
            }
            //没有的情况
            else
            {
                eventDic.Add(name, new EventInfo(action));
            }
        }

        /// <summary>
        /// 移除对应的事件监听(有参)
        /// </summary>
        /// <param name="name">事件的名字</param>
        /// <param name="action">对应之前添加的委托函数</param>
        public void RemoveEventListener<T>(string name, UnityAction<T> action)
        {
            if (eventDic.ContainsKey(name))
                (eventDic[name] as EventInfo<T>).actions -= action;
        }

        /// <summary>
        /// 移除对应的事件监听(无参)
        /// </summary>
        /// <param name="name">事件的名字</param>
        /// <param name="action">对应之前添加的委托函数</param>
        public void RemoveEventListener(string name, UnityAction action)
        {
            if (eventDic.ContainsKey(name))
                (eventDic[name] as EventInfo).actions -= action;
        }

        /// <summary>
        /// 事件触发(有参)
        /// </summary>
        /// <param name="name">触发的事件名</param>
        public void EventTrigger<T>(string name, T info)
        {
            //有没有对应的事件监听
            //有的情况
            if (eventDic.ContainsKey(name))
            {
                //eventDic[name]();
                if ((eventDic[name] as EventInfo<T>).actions != null)
                    (eventDic[name] as EventInfo<T>).actions.Invoke(info);
                //eventDic[name].Invoke(info);
            }
        }

        /// <summary>
        /// 事件触发(无参)
        /// </summary>
        /// <param name="name">触发的事件名</param>
        public void EventTrigger(string name)
        {
            //有没有对应的事件监听
            //有的情况
            if (eventDic.ContainsKey(name))
            {
                //eventDic[name]();
                if ((eventDic[name] as EventInfo).actions != null)
                    (eventDic[name] as EventInfo).actions.Invoke();
                //eventDic[name].Invoke(info);
            }
        }

        /// <summary>
        /// 清空事件中心
        /// 主要用在 场景切换时
        /// </summary>
        public void Clear()
        {
            eventDic.Clear();
        }
    }
}
```

```csharp
// 创建EventCenter的实例
EventCenter eventCenter = EventCenter.GetInstance();

// 添加事件监听，当事件发生时，执行对应的方法
void Start()
{
	eventCenter.AddEventListener("PlayerDeath", PlayerDeathHandler);
	eventCenter.AddEventListener<int>("MonsterKilled", MonsterKilledHandler);
}

// 移除事件监听
void OnDestroy()
{
	eventCenter.RemoveEventListener("PlayerDeath", PlayerDeathHandler);
	eventCenter.RemoveEventListener<int>("MonsterKilled", MonsterKilledHandler);
}

// 触发事件
eventCenter.EventTrigger("PlayerDeath");
eventCenter.EventTrigger<int>(123, 100); // 假设123是怪物ID，100是怪物的生命值

// 清空事件中心
eventCenter.Clear();

// 定义事件处理方法
void PlayerDeathHandler() {
    Debug.Log("Player has died!");
}

void MonsterKilledHandler(int monsterId) {
    Debug.Log($"Monster with ID {monsterId} has been killed!");
}

//lambda
EventCenter.GetInstance().AddEventListener<int>("AddTimer", (i) => { 
Debug.Log("AddTimer" + i);});
```

怪物类
```cs
public class Monster
{
    public int Id { get; private set; }
    public string Name { get; private set; }
    
    // 怪物死亡事件的名称
    private const string MonsterKilledEventName = "MonsterKilled";

    public Monster(int id, string name)
    {
        Id = id;
        Name = name;
    }

    // 怪物死亡的方法
    public void Die()
    {
        Debug.Log($"{Name} has died!");
        // 通过EventCenter触发怪物死亡事件
        EventCenter.GetInstance().EventTrigger<int>(MonsterKilledEventName, Id);
    }
    
    // 移除事件监听
	void OnDestroy()
	{
		EventCenter.GetInstance().RemoveEventListener<int>(MonsterKilledEventName, PlayerDeathHandler);
	}
}
```
玩家类，添加事件监听
```cs
public class Player
{
    // 玩家的构造函数
    public Player()
    {
        // 监听怪物死亡事件
        EventCenter.GetInstance().AddEventListener<int>(Monster.MonsterKilledEventName, OnMonsterKilled);
    }

    // 怪物死亡时的处理方法,获取经验什么的
    private void OnMonsterKilled(int monsterId)
    {
        Debug.Log($"Player received notification that monster with ID {monsterId} has been killed.");
    }
}
```

在决定使用数组或字典等数据结构来传递多个参数与声明多个泛型参数之间进行比较时，需要考虑多个因素，包括代码的可读性、性能、灵活性以及具体的使用场景。以下是这两种方法的优缺点分析：

### 使用多个泛型参数
**优点**：
1. **类型安全**：每个参数都明确指定了类型，这有助于在编译时捕获类型错误。
2. **可读性强**：方法的签名清晰地表明了每个参数的类型和用途，使得代码易于理解和维护。
3. **性能较好**：由于类型在编译时确定，避免了运行时的装箱和拆箱操作（对于值类型）。

**缺点**：
1. **灵活性较低**：如果事件处理函数需要的参数数量或类型发生变化，需要修改方法的签名，这可能导致大量的代码修改。
2. **代码重复**：如果有很多不同参数列表的事件处理函数，需要为每个组合编写不同的泛型方法。

### 使用数组或字典等数据结构
**优点**：
1. **灵活性高**：可以处理任意数量和类型的参数，非常适合参数列表不固定的情况。
2. **代码简洁**：减少了为每种可能的参数组合编写单独方法的需要。

**缺点**：
1. **类型安全性较低**：使用数组或字典时，通常需要以某种方式（如字符串键或索引）来标识参数，这可能导致运行时错误，如类型不匹配或索引越界。
2. **性能较差**：对于值类型，数组或字典的使用可能导致装箱和拆箱操作，这会增加性能开销。
3. **可读性差**：方法的签名不再清晰地表明参数的类型和用途，需要查看文档或代码注释来理解。

### 结论
选择哪种方法取决于具体的使用场景：
- 如果事件处理函数的参数数量和类型在大多数情况下是固定的，并且类型安全是首要考虑的因素，那么使用多个泛型参数是更好的选择。
- 如果事件处理函数的参数数量和类型变化较大，并且灵活性是首要考虑的因素，那么使用数组或字典等数据结构可能更合适。

在实际开发中，还可以考虑将两种方法结合起来，例如使用泛型方法来处理固定数量和类型的参数，同时提供非泛型重载来接受一个包含所有参数的数组或字典，以兼顾类型安全和灵活性。
```cs
//lambda
EventCenter.GetInstance().AddEventListener<int, string>("AddTimer", (i,j) => {
    Debug.Log("AddTimer" + i + j);
});

//lambda
EventCenter.GetInstance().AddEventListener<Dictionary<int, Timer>>("AddTimer", (timers) => {
    Debug.Log("AddTimer" + timers[1]);
});
```


![[Pasted image 20241211171111.png]]
存在装箱拆箱，优化如下：
private Dictionary<string, IEventInfo> eventDic = new Dictionary<string, IEventInfo>();

使用里氏替换，父类装子类
定义一个接口IEventInfo做父类；
子类继承接口，并实现（泛型）委托，字典值存接口，使用时使用as转换成子类
